<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>System 6 - CELL.LIFE</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    
    <!-- Load D3.js for charting -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        /* --- System 6 Theme Styles --- */
        :root {
            --sys-black: #000;
            --sys-white: #fff;
            --sys-grey: #aaa; 
            --shadow: 2px 2px 0px var(--sys-black);
            --cell-alive: #000;
            --cell-dead: #fff;
            --cell-border: #999;
        }

        body {
            font-family: 'VT323', monospace;
            background-color: #f0f0f0;
            /* Retro background pattern */
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), 
                              linear-gradient(-45deg, #ccc 25%, transparent 25%), 
                              linear-gradient(45deg, transparent 75%, #ccc 75%), 
                              linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 4px 4px;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 10vh;
            color: var(--sys-black);
            user-select: none;
            -webkit-user-select: none;
        }

        /* The Main Window */
        .window {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            box-shadow: 4px 4px 0px rgba(0,0,0,0.2);
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            margin-bottom: 20px;
        }

        /* Title Bar */
        .title-bar {
            background: var(--sys-black);
            color: var(--sys-white);
            padding: 4px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--sys-black);
            font-size: 1.2rem;
            letter-spacing: 1px;
        }
        
        .title-lines {
            flex-grow: 1;
            height: 12px;
            margin: 0 10px;
            background: repeating-linear-gradient(
                to bottom,
                var(--sys-white),
                var(--sys-white) 1px,
                var(--sys-black) 1px,
                var(--sys-black) 2px
            );
        }

        .close-box {
            width: 12px;
            height: 12px;
            background: var(--sys-white);
            border: 1px solid var(--sys-white);
            box-shadow: inset 1px 1px 0 #000;
            cursor: pointer;
        }

        /* --- Menu Bar Styles --- */
        .menu-bar {
            display: flex;
            background: var(--sys-grey);
            border-bottom: 2px solid var(--sys-black);
            font-size: 1.1rem;
            padding: 2px 0;
            z-index: 10;
            flex-wrap: wrap;
        }

        .menu-item {
            position: relative;
            padding: 2px 10px;
            cursor: pointer;
            border-right: 1px solid var(--sys-black);
            white-space: nowrap;
        }
        
        .menu-item:hover {
            background: var(--sys-black);
            color: var(--sys-white);
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            box-shadow: 4px 4px 0px rgba(0,0,0,0.2);
            padding: 5px;
            min-width: 180px;
            z-index: 100;
            flex-direction: column;
            gap: 5px;
        }

        .menu-item:hover .dropdown-content {
            display: flex;
        }
        
        /* Dropdown Controls - Retro Style Fix */
        .dropdown-content button, 
        .dropdown-content select, 
        .dropdown-content option,
        .dropdown-content optgroup,
        .dropdown-content label {
            width: 100%;
            text-align: left;
            background: var(--sys-white);
            border: none;
            padding: 5px;
            font-family: 'VT323', monospace; /* Ensure retro font */
            font-size: 1rem;
            cursor: pointer;
            box-shadow: none;
            transition: background 0.1s;
            color: var(--sys-black);
            box-sizing: border-box;
        }
        .dropdown-content button:hover, 
        .dropdown-content button:focus,
        .dropdown-content option:hover {
            background: var(--sys-black);
            color: var(--sys-white);
        }
        
        /* The Select Box Itself */
        .dropdown-content select {
            border: 2px solid var(--sys-black);
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            padding: 3px 5px;
            background-image: linear-gradient(45deg, transparent 50%, var(--sys-black) 50%),
                              linear-gradient(135deg, var(--sys-black) 50%, transparent 50%);
            background-position: calc(100% - 12px) center, calc(100% - 7px) center;
            background-size: 5px 5px, 5px 5px;
            background-repeat: no-repeat;
        }
        /* Make select options retro when focused */
        .dropdown-content select:focus, 
        .dropdown-content select:active {
            outline: none;
            box-shadow: 2px 2px 0px var(--sys-black);
        }
        
        .menu-divider {
            height: 1px;
            background: var(--sys-black);
            margin: 5px 0;
            width: 100%;
        }


        /* Main Content Area */
        .content {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* Canvas Area */
        .canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            background: #e0e0e0;
            padding: 10px;
            border: 1px inset var(--sys-black);
        }

        canvas {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            cursor: crosshair;
            image-rendering: pixelated;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            
            /* Responsive resizing */
            width: 100%;
            height: auto;
            max-width: 320px; /* Limit max size */
            aspect-ratio: 1 / 1; 
            touch-action: none;
        }

        /* Simulation Controls */
        .simulation-controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .control-group-row {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .btn {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            padding: 5px 10px;
            font-family: 'VT323', monospace;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 2px 2px 0px var(--sys-black);
            transition: transform 0.1s;
            text-transform: uppercase;
            text-decoration: none;
            color: var(--sys-black);
            display: inline-block;
            text-align: center;
        }

        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: none;
            background: var(--sys-black);
            color: var(--sys-white);
        }

        .btn:disabled {
            color: #aaa;
            border-color: #aaa;
            box-shadow: none;
            cursor: default;
        }
        
        .speed-control-container {
            align-items: center;
        }

        label {
            font-size: 1.1rem;
        }

        input[type="range"] {
            -webkit-appearance: none;
            background: transparent;
            width: 100px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            background: var(--sys-black);
            cursor: pointer;
            margin-top: -6px;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: var(--sys-black);
        }

        /* Info Panel */
        .info-panel {
            font-size: 1rem;
            text-align: center;
            padding: 5px 0 0;
            border-top: 1px dashed var(--sys-black);
        }
        
        /* Analysis Panel & D3 Chart Styles */
        .analysis-panel {
            padding: 10px; 
            border-top: 2px solid var(--sys-black); 
            background: #eee;
        }
        #population-chart {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            padding: 5px;
            font-family: 'VT323', monospace;
            box-sizing: border-box; 
        }
        #population-chart svg text {
            fill: var(--sys-black);
            font-family: 'VT323', monospace;
            font-size: 14px;
        }
        #population-chart svg path.population-line {
            stroke: #d90429; /* Red line for tracking */
        }
        #population-chart svg path.domain,
        #population-chart svg line {
            stroke: var(--sys-black);
        }
        /* Style for Rules in Help Modal */
        .rule-visual {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            width: 60px;
            height: 60px;
            border: 2px solid var(--sys-black);
            box-sizing: content-box;
        }
        
        .rule-visual .cell {
            border: 1px solid var(--cell-border);
            background: var(--cell-dead);
        }
        .rule-visual .cell.alive {
            background: var(--cell-alive);
        }
        .rule-visual .cell.center-cell {
            border-width: 2px;
            border-color: #0000ff; /* Blue border for the cell being evaluated */
        }


        /* Retro Modal Styles */
        .retro-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .retro-modal-window {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            box-shadow: 6px 6px 0px rgba(0,0,0,0.5);
            width: 95%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-content {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
            text-align: center;
        }

        .modal-text {
            font-size: 1.1rem;
            font-weight: bold;
            color: #d90429; /* A retro red for warnings */
            padding: 5px;
            border: 1px dashed var(--sys-black);
            width: 100%;
            box-sizing: border-box;
            text-align: left;
        }

        /* Responsive */
        @media (max-width: 500px) {
            body { padding: 5px; }
            .btn { font-size: 0.9rem; padding: 4px 6px; }
            .control-group-row { justify-content: center;}
            .menu-bar { justify-content: center; }
        }
    </style>
</head>
<body>

<div class="window">
    <div class="title-bar">
        <div class="close-box" onclick="closeModal('halt')"></div>
        <div class="title-lines"></div>
        <span>CELL.LIFE</span>
        <div class="title-lines"></div>
    </div>
    
    <!-- MENU BAR -->
    <nav class="menu-bar">
        <div class="menu-item">FILE
            <div class="dropdown-content">
                <button onclick="resetSimulation()">[?] Reset All</button>
                <button onclick="showHelpModal()">[?] Help/Rules</button>
                <div class="menu-divider"></div>
                <label for="grid-size">Grid Size:</label>
                <select id="grid-size" onchange="changeGridSize()">
                    <option value="16">16x16</option>
                    <option value="32" selected>32x32</option>
                    <option value="64">64x64</option>
                </select>
            </div>
        </div>
        
        <div class="menu-item">EDIT
            <div class="dropdown-content">
                <button onclick="clearGrid()">Clear Grid</button>
                <button onclick="randomizeGrid()">Randomize</button>
            </div>
        </div>
        
        <div class="menu-item">PATTERNS
            <div class="dropdown-content">
                <select id="pattern-selector" onchange="loadSelectedPattern()">
                    <option value="">-- Add a Pattern (Randomly) --</option>
                    <optgroup label="Still Lifes (Stable)">
                        <option value="block">Block</option>
                        <option value="beehive">Beehive</option>
                        <option value="boat">Boat</option>
                    </optgroup>
                    <optgroup label="Oscillators (Repeating)">
                        <option value="blinker">Blinker (P=2)</option>
                        <option value="toad">Toad (P=2)</option>
                        <option value="pulsar">Pulsar (P=3)</option>
                        <option value="penta_decalon">Penta-decalon (P=15)</option>
                    </optgroup>
                    <optgroup label="Growers (Complex)">
                        <option value="r_pentomino">R-Pentomino</option>
                        <option value="acorn">Acorn</option>
                    </optgroup>
                    <optgroup label="Spaceships (Moving)">
                        <option value="glider">Glider (The Classic)</option>
                        <option value="lwss">Lightweight Spaceship</option>
                    </optgroup>
                </select>
            </div>
        </div>
        
    </nav>
    <!-- END MENU BAR -->


    <div class="content">
        <!-- Main Canvas -->
        <div class="canvas-container">
            <canvas id="editorCanvas" width="320" height="320"></canvas>
        </div>

        <!-- Simulation Controls -->
        <div class="simulation-controls">
            <div class="control-group-row">
                <!-- Buttons for the two running modes. Start(true) halts, Start(false) runs forever -->
                <button class="btn" id="run-halting-btn" onclick="startSimulation(true)">&#9658; START (One Run)</button>
                <button class="btn" id="run-forever-btn" onclick="startSimulation(false)">&#9658; RUN FOREVER</button>
                <button class="btn" id="stop-btn" onclick="stopSimulation()" style="display:none; background: #d90429; color: white; font-weight:bold;">&#9632; STOP</button>
            </div>
            
            <div class="control-group-row">
                <button class="btn" id="step-btn" onclick="stepSimulation()">STEP</button>
                <button class="btn" id="step-back-btn" onclick="stepBack()" disabled>&lt; BACK</button> 
            </div>

            <div class="control-group-row speed-control-container">
                <label>Speed:</label>
                <input type="range" id="speed-range" min="1" max="20" value="8" oninput="updateSpeed()">
            </div>
        </div>

        <!-- Info Panel -->
        <div class="info-panel">
            Generation: <span id="generation-indicator">0</span> | Population: <span id="population-indicator">0</span>
        </div>
    </div>
    
    <!-- Population Analysis Panel -->
    <div class="analysis-panel">
        <h3 style="font-size: 1.1rem; margin: 0 0 5px; text-align: center;">Population Analysis (Live)</h3>
        <div id="population-chart">
            <!-- D3 line chart will be injected here -->
        </div>
    </div>
    <!-- END Analysis Panel -->
    
</div>

<!-- Modals -->
<div id="haltModal" class="retro-modal-overlay" style="display: none;">
    <div class="retro-modal-window">
        <div class="title-bar">
            <div class="close-box" onclick="closeModal('halt')"></div>
            <div class="title-lines"></div>
            <span>SYSTEM ALERT</span>
            <div class="title-lines"></div>
        </div>
        <div class="modal-content">
            <p style="font-size: 1.2rem; margin-bottom: 10px;">MESSAGE:</p>
            <div id="modal-halt-reason" class="modal-text" style="text-align: center; color: var(--sys-black);"></div>
            <p>Generation: <span id="modal-halt-generation">0</span></p>
            <p>Population: <span id="modal-halt-population">0</span></p>
            <button class="btn" onclick="closeModal('halt')">OKAY</button>
        </div>
    </div>
</div>

<div id="helpModal" class="retro-modal-overlay" style="display: none;">
    <div class="retro-modal-window">
        <div class="title-bar">
            <div class="close-box" onclick="closeModal('help')"></div>
            <div class="title-lines"></div>
            <span>CELL.LIFE - RULES GUIDE</span>
            <div class="title-lines"></div>
        </div>
        <div class="modal-content">
            <p style="font-size: 1.2rem; margin-bottom: 5px;">HOW THE GAME WORKS</p>
            <p style="text-align: left; font-size: 0.9rem;">
                This game uses simple rules to create complex patterns. You set up the first pattern by clicking on the grid to make cells ALIVE (black). When you press START, every cell changes based on its 8 neighbors (the cells touching it).
            </p>
            
            <p style="font-size: 1.2rem; margin-top: 10px; margin-bottom: 5px;">THE FOUR SIMPLE RULES</p>

            <div id="rules-container" style="width: 100%;"></div>

            <button class="btn" onclick="closeModal('help')">I GOT IT</button>
        </div>
    </div>
</div>


<script>
    // --- Configuration ---
    let gridSize = 32; // Defaulted to 32x32 for better pattern support
    const canvasSize = 320; 
    let pixelSize = canvasSize / gridSize;
    
    // --- State ---
    let grid = []; // 2D array: 0=dead, 1=alive
    let generation = 0;
    let population = 0;
    let gridHistory = []; // Stores previous grid states
    const maxHistory = 10; // Only store the last N generations for oscillation check
    let populationHistory = []; // Stores {generation, population} for charting
    let initialPopulation = 0; // Stores population at G0 
    
    let isRunning = false;
    let isHaltingEnabled = true;
    let runInterval = null;
    let fps = 8;

    // --- D3/Graph variables ---
    const chartMargin = { top: 10, right: 10, bottom: 20, left: 30 };
    const chartHeightTotal = 150;
    let chartWidth = 0;
    let chartHeight = chartHeightTotal - chartMargin.top - chartMargin.bottom;
    let svg; 
    const MAX_VISIBLE_GENERATIONS = 200; // Constant for scrolling window
    
    
    // --- DOM Elements ---
    const canvas = document.getElementById('editorCanvas');
    const ctx = canvas.getContext('2d');
    const runHaltingBtn = document.getElementById('run-halting-btn');
    const runForeverBtn = document.getElementById('run-forever-btn');
    const stopBtn = document.getElementById('stop-btn');
    const stepBtn = document.getElementById('step-btn');
    const stepBackBtn = document.getElementById('step-back-btn');
    const genIndicator = document.getElementById('generation-indicator');
    const popIndicator = document.getElementById('population-indicator');

    // Halting Modal Elements
    const haltModal = document.getElementById('haltModal');
    const modalHaltReason = document.getElementById('modal-halt-reason');
    const modalHaltGen = document.getElementById('modal-halt-generation');
    const modalHaltPop = document.getElementById('modal-halt-population');
    
    // Help Modal Elements
    const helpModal = document.getElementById('helpModal');
    const rulesContainer = document.getElementById('rules-container');
    
    // --- Pattern Definitions (Expanded) ---
    const PATTERNS = {
        // Still Lifes (Stable)
        block: [[0, 0], [1, 0], [0, 1], [1, 1]], 
        beehive: [[1, 0], [2, 0], [0, 1], [3, 1], [1, 2], [2, 2]], 
        boat: [[0, 0], [1, 0], [0, 1], [2, 1], [1, 2]], 
        
        // Oscillators (Repeating)
        blinker: [[0, 1], [1, 1], [2, 1]], 
        toad: [[1, 0], [2, 0], [3, 0], [0, 1], [1, 1], [2, 1]], 
        pulsar: [ 
            [2, 0], [3, 0], [4, 0], [8, 0], [9, 0], [10, 0],
            [0, 2], [5, 2], [7, 2], [12, 2],
            [0, 3], [5, 3], [7, 3], [12, 3],
            [0, 4], [5, 4], [7, 4], [12, 4],
            [2, 5], [3, 5], [4, 5], [8, 5], [9, 5], [10, 5],
            [2, 7], [3, 7], [4, 7], [8, 7], [9, 7], [10, 7],
            [0, 8], [5, 8], [7, 8], [12, 8],
            [0, 9], [5, 9], [7, 9], [12, 9],
            [0, 10], [5, 10], [7, 10], [12, 10],
            [2, 12], [3, 12], [4, 12], [8, 12], [9, 12], [10, 12]
        ],
        penta_decalon: [
            [4, 0], [5, 0], [6, 0], [7, 0], [8, 0], [9, 0], [10, 0], [11, 0], 
            [4, 1], [11, 1], 
            [4, 2], [5, 2], [6, 2], [7, 2], [8, 2], [9, 2], [10, 2], [11, 2],
            [4, 4], [5, 4], [6, 4], [7, 4], [8, 4], [9, 4], [10, 4], [11, 4], 
            [4, 5], [11, 5], 
            [4, 6], [5, 6], [6, 6], [7, 6], [8, 6], [9, 6], [10, 6], [11, 6],
        ],

        // Growers (Complex/Monomers)
        r_pentomino: [
            [1, 0], [2, 0], 
            [0, 1], [1, 1], 
            [1, 2]
        ],
        acorn: [
            [1, 0], 
            [3, 1],
            [0, 2], [1, 2], [4, 2], [5, 2], [6, 2]
        ],
        
        // Spaceships (Moving)
        glider: [[1, 0], [2, 1], [0, 2], [1, 2], [2, 2]], 
        lwss: [ 
            [1, 0], [4, 0],
            [0, 1], [0, 2], [4, 2],
            [0, 3], [1, 3], [2, 3], [3, 3]
        ],
    };


    // --- Initialization ---
    function init() {
        // Find the selected size from the dropdown (defaulting to 32x32)
        const select = document.getElementById('grid-size');
        gridSize = parseInt(select.value);
        pixelSize = canvasSize / gridSize;

        grid = createNewGrid(gridSize);
        gridHistory = []; 
        populationHistory = []; 
        generation = 0;
        population = 0;
        initialPopulation = 0;
        
        initGraph(); 
        render();
        updateUI();
        injectRuleVisuals(); 
    }
    
    // --- Graphing Logic ---

    /** Initializes the D3 SVG container and axes. */
    function initGraph() {
        const container = document.getElementById('population-chart');
        if (!container) return;
        
        // Adjust chart width based on the actual container size (minus padding/margins)
        const containerBlock = document.querySelector('.analysis-panel');
        chartWidth = containerBlock.offsetWidth - 20 - chartMargin.left - chartMargin.right;
        
        d3.select(container).select("svg").remove();

        svg = d3.select(container).append("svg")
            .attr("width", chartWidth + chartMargin.left + chartMargin.right)
            .attr("height", chartHeightTotal)
          .append("g")
            .attr("transform", `translate(${chartMargin.left},${chartMargin.top})`);
            
        svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", `translate(0,${chartHeight})`);

        svg.append("g")
            .attr("class", "y-axis");
            
        svg.append("path")
            .attr("class", "population-line")
            .attr("fill", "none")
            .attr("stroke", "#d90429")
            .attr("stroke-width", 2);
            
        updateGraph();
    }

    /** Updates the D3 line graph with the current population data and implements scrolling X-axis and dynamic Y-axis. */
    function updateGraph() {
        if (!svg) return;
        
        const data = populationHistory;
        const totalCells = gridSize * gridSize;

        // 1. Determine X-Axis Domain (Scrolling Logic)
        let minGen, maxGenD3;
        
        if (generation <= MAX_VISIBLE_GENERATIONS) {
            minGen = 0;
            maxGenD3 = MAX_VISIBLE_GENERATIONS; 
        } else {
            minGen = generation - MAX_VISIBLE_GENERATIONS; 
            maxGenD3 = generation;                         
        }

        // 2. Filter data to the visible X-axis range
        const visibleData = data.filter(d => d.generation >= minGen);

        // 3. Determine Dynamic Y-Axis Domain (Population)
        let minPopVisible = 0;
        let maxPopVisible = 50; 
        
        if (visibleData.length > 0) {
            const currentMinPop = d3.min(visibleData, d => d.population);
            const currentMaxPop = d3.max(visibleData, d => d.population);

            const range = currentMaxPop - currentMinPop;
            const paddingFactor = 0.1; 
            
            if (range === 0) {
                minPopVisible = Math.max(0, currentMinPop - 5);
                maxPopVisible = currentMaxPop + 5;
            } else {
                const padding = range * paddingFactor;
                minPopVisible = Math.max(0, currentMinPop - padding); 
                maxPopVisible = Math.min(totalCells, currentMaxPop + padding);
            }
            
        } else if (generation === 0) {
            minPopVisible = 0;
            maxPopVisible = Math.max(10, population + 5); 
        }

        // 4. Scales
        const xScale = d3.scaleLinear()
            .domain([minGen, maxGenD3]) 
            .range([0, chartWidth]);

        const yScale = d3.scaleLinear()
            .domain([minPopVisible, maxPopVisible]) 
            .range([chartHeight, 0]);

        // 5. Line generator
        const line = d3.line()
            .x(d => xScale(d.generation))
            .y(d => yScale(d.population));

        // 6. Update Axes
        const tickCount = Math.min(10, Math.floor((maxGenD3 - minGen) / 20) + 1);

        svg.select(".x-axis")
            .transition().duration(50) 
            .call(d3.axisBottom(xScale).tickFormat(d3.format("d")).ticks(tickCount));
        
        svg.select(".y-axis")
            .transition().duration(50) 
            .call(d3.axisLeft(yScale).ticks(5).tickFormat(d3.format("d"))); 

        svg.selectAll(".x-axis path, .y-axis path, .x-axis line, .y-axis line").attr("stroke", "var(--sys-black)");

        // 7. Update Line Path
        svg.select(".population-line")
            .datum(data)
            .transition().duration(50)
            .attr("d", line);
    }
    
    window.addEventListener('resize', () => {
        initGraph();
    });


    // --- Grid Logic ---

    function createNewGrid(size) {
        const newGrid = [];
        for (let y = 0; y < size; y++) {
            let row = [];
            for (let x = 0; x < size; x++) {
                row.push(0);
            }
            newGrid.push(row);
        }
        return newGrid;
    }

    function resetSimulation() {
        if (isRunning) stopSimulation();
        grid = createNewGrid(gridSize);
        generation = 0;
        population = 0;
        gridHistory = []; 
        populationHistory = []; 
        initialPopulation = 0;
        render();
        updateUI();
        updateGraph(); 
        document.getElementById('pattern-selector').value = ""; 
    }

    function clearGrid() {
        grid = createNewGrid(gridSize);
        generation = 0;
        population = 0;
        gridHistory = []; 
        populationHistory = []; 
        initialPopulation = 0;
        render();
        updateUI();
        updateGraph(); 
        document.getElementById('pattern-selector').value = "";
    }

    function randomizeGrid() {
        if (isRunning) stopSimulation();
        const newGrid = [];
        for (let y = 0; y < gridSize; y++) {
            let row = [];
            for (let x = 0; x < gridSize; x++) {
                row.push(Math.random() < 0.3 ? 1 : 0);
            }
            newGrid.push(row);
        }
        grid = newGrid;
        generation = 0;
        gridHistory = []; 
        populationHistory = []; 
        updatePopulation(); 
        initialPopulation = population; // Set G0 population
        render();
        updateUI();
        updateGraph(); 
        document.getElementById('pattern-selector').value = "";
    }

    function changeGridSize() {
        const select = document.getElementById('grid-size');
        const newSize = parseInt(select.value);
        
        if (population > 0 || generation > 0) {
            // Note: window.confirm used here as per requirements, replace with modal if required
            const confirmed = window.confirm("Changing grid size will reset the current pattern and generation count. Continue?");
            if (!confirmed) {
                select.value = gridSize; 
                return;
            }
        }
        
        gridSize = newSize;
        pixelSize = canvasSize / gridSize;
        resetSimulation();
    }
    
    // --- Pattern Additive Placement Logic (NEW) ---

    function getPatternBounds(pattern) {
        if (pattern.length === 0) return { width: 0, height: 0, minX: 0, minY: 0 };
        
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        pattern.forEach(([x, y]) => {
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
        });
        return {
            width: maxX - minX + 1,
            height: maxY - minY + 1,
            minX: minX,
            minY: minY
        };
    }

    function canPlacePattern(pattern, offsetX, offsetY, bounds) {
        const { width, height, minX, minY } = bounds;

        // Boundary check
        if (offsetX < 0 || offsetY < 0 || 
            offsetX + width > gridSize || offsetY + height > gridSize) {
            return false;
        }

        // Collision check
        for (const [px, py] of pattern) {
            const gridX = px + offsetX - minX;
            const gridY = py + offsetY - minY;
            
            // Check if target cell is already occupied
            if (grid[gridY][gridX] === 1) {
                return false; // Collision
            }
        }
        return true; // No collision, within bounds
    }

    function applyPattern(pattern, offsetX, offsetY, bounds) {
        const { minX, minY } = bounds;
        for (const [px, py] of pattern) {
            const gridX = px + offsetX - minX;
            const gridY = py + offsetY - minY;
            grid[gridY][gridX] = 1; // Set cell to alive
        }
    }

    function loadSelectedPattern() {
        const selector = document.getElementById('pattern-selector');
        const patternKey = selector.value;
        
        if (!patternKey || !PATTERNS[patternKey]) return;
        if (isRunning) stopSimulation();
        
        const pattern = PATTERNS[patternKey];
        const bounds = getPatternBounds(pattern);
        const patternWidth = bounds.width;
        const patternHeight = bounds.height;
        
        // Safety check for pattern size
        if (patternWidth > gridSize || patternHeight > gridSize) {
             selector.value = "";
             showHaltModal(`Pattern "${patternKey}" is too large for the current ${gridSize}x${gridSize} grid. Try switching to 32x32 or 64x64.`, 'Pattern Load Error');
             return;
        }
        
        let placed = false;
        const MAX_ATTEMPTS = 50;

        // Define the boundaries for random offset generation
        const maxXOffset = gridSize - patternWidth;
        const maxYOffset = gridSize - patternHeight;

        for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
            // Randomly choose the top-left corner of the pattern's bounding box
            const randX = Math.floor(Math.random() * (maxXOffset + 1));
            const randY = Math.floor(Math.random() * (maxYOffset + 1));

            if (canPlacePattern(pattern, randX, randY, bounds)) {
                applyPattern(pattern, randX, randY, bounds);
                placed = true;
                break;
            }
        }

        if (!placed) {
            showHaltModal(`Could not find a clear space to place the ${patternKey} pattern after ${MAX_ATTEMPTS} attempts. Try clearing the grid or choosing a smaller pattern.`, 'No Room Available');
            selector.value = ""; // Reset selector
            return;
        }

        // Update state and UI
        if (generation === 0 && gridHistory.length === 0) {
             // Save G0 state for stepBack, only if this is the first pattern interaction
             gridHistory.push(grid.map(row => [...row])); 
             initialPopulation = population; // Snapshot initial pop
        }

        updatePopulation(); 
        render();
        updateUI();
        updateGraph(); 
        selector.value = ""; // Reset selector after placement
    }


    // --- Conway's Game of Life Core Logic ---
    
    function countNeighborsForGrid(x, y, targetGrid) {
        let count = 0;
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue; 
                const nx = (x + dx + gridSize) % gridSize;
                const ny = (y + dy + gridSize) % gridSize;
                count += targetGrid[ny][nx];
            }
        }
        return count;
    }

    function calculateNextGeneration(inputGrid) {
        const nextGrid = createNewGrid(gridSize); 
        let liveCount = 0;

        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                const neighbors = countNeighborsForGrid(x, y, inputGrid);
                const state = inputGrid[y][x];

                const isAlive = state === 1;
                let newState = 0;

                // Rule 1 & 3: Loneliness and Overcrowding
                if (isAlive && (neighbors === 2 || neighbors === 3)) {
                    newState = 1; // Rule 2: Survival
                } else if (!isAlive && neighbors === 3) {
                    newState = 1; // Rule 4: Birth
                }
                
                nextGrid[y][x] = newState;

                if (newState === 1) {
                    liveCount++;
                }
            }
        }
        return { nextGrid, liveCount };
    }
    
    function checkStopConditions(currentGrid, nextGrid, liveCount) {
        const totalCells = gridSize * gridSize;
        let reason = null;

        if (liveCount === 0) {
            reason = "EMPTY! All the cells died. No life left on the grid.";
        } else if (liveCount === totalCells) {
            reason = "FULL HOUSE! The entire grid is full of living cells.";
        }
        
        const currentGridString = JSON.stringify(currentGrid);
        const nextGridString = JSON.stringify(nextGrid);
        
        if (!reason && currentGridString === nextGridString) {
            reason = "STABLE! The pattern is perfectly still and won't change.";
        }
        
        if (!reason) {
            for (let i = 0; i < gridHistory.length; i++) {
                if (nextGridString === JSON.stringify(gridHistory[i])) {
                    const matchedGen = generation - gridHistory.length + i + 1;
                    reason = `LOOP DETECTED! The pattern is repeating in a circle (State matches Generation ${matchedGen}).`;
                    break;
                }
            }
        }
        
        return reason;
    }


    // --- Drawing Engine ---

    function drawGridLines(ctx, size, pixelSize) {
        const canvasDim = size * pixelSize;
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 0; i <= size; i++) {
            ctx.moveTo(i * pixelSize, 0);
            ctx.lineTo(i * pixelSize, canvasDim);
            ctx.moveTo(0, i * pixelSize);
            ctx.lineTo(canvasDim, i * pixelSize);
        }
        ctx.stroke();
    }

    function drawPixel(ctx, x, y, color, pixelSize) {
        ctx.fillStyle = color;
        const gap = 0; 
        ctx.fillRect(x * pixelSize + gap, y * pixelSize + gap, pixelSize - gap*2, pixelSize - gap*2);
    }

    function render() {
        ctx.clearRect(0, 0, canvasSize, canvasSize);
        drawGridLines(ctx, gridSize, pixelSize);

        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                if (grid[y][x] === 1) {
                    drawPixel(ctx, x, y, '#000', pixelSize); 
                }
            }
        }
    }


    // --- Interaction ---

    function getGridCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        const x = Math.floor((clientX - rect.left) / (rect.width / gridSize));
        const y = Math.floor((clientY - rect.top) / (rect.height / gridSize));
        return { x, y };
    }

    function handleToggle(e) {
        if (isRunning) return;
        
        const { x, y } = getGridCoords(e);
        if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
            const newState = 1 - grid[y][x]; 
            if (grid[y][x] !== newState) {
                if (generation === 0 && gridHistory.length === 0) {
                     // Save G0 state for stepBack
                     gridHistory.push(grid.map(row => [...row])); 
                     initialPopulation = population; // Snapshot initial pop
                }
                grid[y][x] = newState;
                render();
                updatePopulation();
                updateUI();
            }
        }
        if (e.cancelable) e.preventDefault();
    }

    let isDrawing = false;
    canvas.addEventListener('mousedown', (e) => { 
        if (!isRunning) handleToggle(e); 
        isDrawing = true; 
    });
    window.addEventListener('mouseup', () => { isDrawing = false; });
    
    canvas.addEventListener('mousemove', (e) => {
        if (isDrawing && !isRunning) handleToggle(e);
    });

    canvas.addEventListener('touchstart', (e) => { 
        if (!isRunning) handleToggle(e); 
        isDrawing = true; 
    }, {passive: false});
    canvas.addEventListener('touchend', () => { isDrawing = false; });

    canvas.addEventListener('touchmove', (e) => {
        if (isDrawing && !isRunning) handleToggle(e);
    }, {passive: false});


    // --- Modal Functions ---

    function showHaltModal(reason, title = 'SIMULATION HALTED') {
        document.querySelector('#haltModal .title-bar span').innerText = title;
        modalHaltReason.innerText = reason;
        modalHaltGen.innerText = generation;
        modalHaltPop.innerText = population;
        haltModal.style.display = 'flex';
    }

    function showHelpModal() {
        helpModal.style.display = 'flex';
    }
    
    function closeModal(type) {
        if (type === 'halt') {
            haltModal.style.display = 'none';
            document.querySelector('#haltModal .title-bar span').innerText = 'SYSTEM ALERT';
        } else if (type === 'help') {
            helpModal.style.display = 'none';
        }
    }

    // --- Help Modal Rule Visuals ---
    function createRuleVisual(neighborPattern, centerState, ruleTitle, ruleText, resultText) {
        const pattern = [
            neighborPattern[0], neighborPattern[1], neighborPattern[2],
            neighborPattern[7], centerState, neighborPattern[3],
            neighborPattern[6], neighborPattern[5], neighborPattern[4]
        ];

        let html = `
        <div class="rule-section">
            <span style="font-weight: bold; font-size: 1.1rem;">${ruleTitle}</span>
            <div style="display: flex; gap: 15px; align-items: center;">
                <div class="rule-visual">
        `;

        for (let i = 0; i < 9; i++) {
            const state = pattern[i];
            const isCenter = i === 4;
            const stateClass = state === 1 ? 'alive' : 'dead';
            const centerClass = isCenter ? 'center-cell' : '';
            html += `<div class="cell ${stateClass} ${centerClass}"></div>`;
        }

        html += `
                </div>
                <div style="text-align: left; font-size: 0.9rem; max-width: 250px;">
                    <p style="margin: 0;">${ruleText}</p>
                    <p style="margin: 5px 0 0; color: #008800; font-weight: bold;">RESULT: ${resultText}</p>
                </div>
            </div>
        </div>
        `;
        return html;
    }

    function injectRuleVisuals() {
        rulesContainer.innerHTML = '';
        let visualsHtml = '';
        
        visualsHtml += createRuleVisual(
            [0, 0, 0, 0, 1, 0, 0, 0], 
            1, "RULE 1: LONELINESS (0 or 1 Neighbor)",
            "If an <span style='color:green;'>ALIVE</span> cell has <span style='color:#d90429;'>fewer than 2</span> living neighbors...",
            "The cell <span style='color:#d90429;'>DIES</span>."
        );
        visualsHtml += createRuleVisual(
            [1, 1, 0, 0, 0, 0, 0, 1], 
            1, "RULE 2: SURVIVAL (2 or 3 Neighbors)",
            "If an <span style='color:green;'>ALIVE</span> cell has <span style='color:green;'>exactly 2 or 3</span> living neighbors...",
            "The cell <span style='color:green;'>STAYS ALIVE</span>."
        );
        visualsHtml += createRuleVisual(
            [1, 1, 1, 1, 0, 0, 0, 0], 
            1, "RULE 3: CROWDING (4+ Neighbors)",
            "If an <span style='color:green;'>ALIVE</span> cell has <span style='color:#d90429;'>more than 3</span> living neighbors...",
            "The cell <span style='color:#d90429;'>DIES</span>."
        );
        visualsHtml += createRuleVisual(
            [1, 1, 1, 0, 0, 0, 0, 0], 
            0, "RULE 4: NEW BIRTH (Exactly 3 Neighbors)",
            "If a <span style='color:#d90429;'>DEAD</span> cell has <span style='color:green;'>exactly 3</span> living neighbors...",
            "The cell <span style='color:green;'>COMES TO LIFE</span>."
        );
        
        rulesContainer.innerHTML = visualsHtml;
    }


    // --- Simulation Controls ---

    function startSimulation(shouldHalt) {
        if (isRunning) stopSimulation();

        if (population === 0 && generation === 0) {
            // Note: window.confirm used here as per requirements, replace with modal if required
            const confirmed = window.confirm("The grid is empty! Start with a random pattern?");
            if (!confirmed) {
                return;
            }
            randomizeGrid();
        }

        isHaltingEnabled = shouldHalt;
        isRunning = true;
        
        runHaltingBtn.style.display = 'none';
        runForeverBtn.style.display = 'none';
        stopBtn.style.display = 'inline-block';
        
        stepBtn.disabled = true;
        stepBackBtn.disabled = true;
        canvas.style.cursor = 'default';
        document.getElementById('grid-size').disabled = true;
        document.getElementById('pattern-selector').disabled = true;

        runInterval = setInterval(() => {
            stepSimulation();
        }, 1000 / fps);
    }

    function stopSimulation() {
        isRunning = false;
        clearInterval(runInterval);
        
        runHaltingBtn.style.display = 'inline-block';
        runForeverBtn.style.display = 'inline-block';
        stopBtn.style.display = 'none';

        stepBtn.disabled = false;
        canvas.style.cursor = 'crosshair';
        document.getElementById('grid-size').disabled = false;
        document.getElementById('pattern-selector').disabled = false;
        updateUI(); 
    }

    function stepSimulation() {
        const currentGridClone = grid.map(row => [...row]); 
        
        const { nextGrid, liveCount } = calculateNextGeneration(currentGridClone);

        let haltReason = null;
        if (isHaltingEnabled) {
            haltReason = checkStopConditions(currentGridClone, nextGrid, liveCount);
        }
        
        gridHistory.push(currentGridClone);
        if (gridHistory.length > maxHistory) {
            gridHistory.shift();
        }

        grid = nextGrid;
        population = liveCount;
        generation++;

        populationHistory.push({ generation: generation, population: population });

        render();
        updateUI();
        updateGraph();

        if (haltReason) {
            stopSimulation();
            showHaltModal(haltReason);
        }
    }
    
    /** Executes one generation step backward, correctly rolling back both history arrays. */
    function stepBack() {
        if (isRunning) stopSimulation();
        
        if (generation > 0) { 
            generation--; 
            populationHistory.pop();

            if (gridHistory.length > 0) {
                grid = gridHistory.pop(); 
            } else {
                 grid = createNewGrid(gridSize);
            }

            updatePopulation(); 
            render();
            updateUI();
            updateGraph(); 
            
            // Re-snapshot initial population if rolling back to G0
            if (generation === 0) {
                initialPopulation = population;
            }
        }
    }


    function updateSpeed() {
        const slider = document.getElementById('speed-range');
        fps = parseInt(slider.value);
        if (isRunning) {
            const wasHalting = isHaltingEnabled;
            stopSimulation();
            startSimulation(wasHalting); 
        }
    }

    function updatePopulation() {
        let count = 0;
        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                if (grid[y][x] === 1) count++;
            }
        }
        population = count;
    }

    // --- UI Update ---

    function updateUI() {
        genIndicator.innerText = generation;
        popIndicator.innerText = population;

        stepBtn.disabled = isRunning;
        stepBackBtn.disabled = isRunning || generation === 0;
        document.getElementById('pattern-selector').disabled = isRunning;
        
        // Ensure START buttons are visible when stopped, RUN FOREVER is always available.
        if (!isRunning) {
             runHaltingBtn.style.display = 'inline-block';
             runForeverBtn.style.display = 'inline-block';
             stopBtn.style.display = 'none';
        }
    }

    // --- Start ---
    window.onload = function() {
        init();
    }
</script>

</body>
</html>
