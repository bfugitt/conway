<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>System 6 - CELL.LIFE</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    
    <style>
        /* --- System 6 Theme Styles --- */
        :root {
            --sys-black: #000;
            --sys-white: #fff;
            --sys-grey: #aaa; 
            --shadow: 2px 2px 0px var(--sys-black);
            --cell-alive: #000;
            --cell-dead: #fff;
            --cell-border: #999;
        }

        body {
            font-family: 'VT323', monospace;
            background-color: #f0f0f0;
            /* Retro background pattern */
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), 
                              linear-gradient(-45deg, #ccc 25%, transparent 25%), 
                              linear-gradient(45deg, transparent 75%, #ccc 75%), 
                              linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 4px 4px;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            color: var(--sys-black);
            user-select: none;
            -webkit-user-select: none;
        }

        /* The Main Window */
        .window {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            box-shadow: 4px 4px 0px rgba(0,0,0,0.2);
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            margin-bottom: 20px;
        }

        /* Title Bar */
        .title-bar {
            background: var(--sys-black);
            color: var(--sys-white);
            padding: 4px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--sys-black);
            font-size: 1.2rem;
            letter-spacing: 1px;
        }
        
        .title-lines {
            flex-grow: 1;
            height: 12px;
            margin: 0 10px;
            background: repeating-linear-gradient(
                to bottom,
                var(--sys-white),
                var(--sys-white) 1px,
                var(--sys-black) 1px,
                var(--sys-black) 2px
            );
        }

        .close-box {
            width: 12px;
            height: 12px;
            background: var(--sys-white);
            border: 1px solid var(--sys-white);
            box-shadow: inset 1px 1px 0 #000;
            cursor: pointer;
        }

        /* Main Content Area */
        .content {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* Toolbar / Control Groups */
        .toolbar {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: space-around;
            padding-bottom: 5px;
            border-bottom: 1px dashed var(--sys-black);
        }

        .btn {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            padding: 5px 10px;
            font-family: 'VT323', monospace;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 2px 2px 0px var(--sys-black);
            transition: transform 0.1s;
            text-transform: uppercase;
            text-decoration: none;
            color: var(--sys-black);
            display: inline-block;
            text-align: center;
        }

        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: none;
            background: var(--sys-black);
            color: var(--sys-white);
        }

        .btn.active {
            background: var(--sys-black);
            color: var(--sys-white);
            box-shadow: inset 2px 2px 0px rgba(255,255,255,0.2);
        }

        .btn:disabled {
            color: #aaa;
            border-color: #aaa;
            box-shadow: none;
            cursor: default;
        }

        .control-group {
            display: flex;
            gap: 5px;
            align-items: center;
            border: 1px solid var(--sys-black);
            padding: 3px;
            flex-wrap: wrap; 
            justify-content: center;
        }

        .control-group-title {
            font-size: 0.8rem;
            font-weight: bold;
        }

        /* Canvas Area */
        .canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            background: #e0e0e0;
            padding: 10px;
            border: 1px inset var(--sys-black);
        }

        canvas {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            cursor: crosshair;
            image-rendering: pixelated;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            
            /* Responsive resizing */
            width: 100%;
            height: auto;
            max-width: 320px; /* Limit max size */
            aspect-ratio: 1 / 1; 
            touch-action: none; /* Prevents scrolling when interacting with the grid */
        }

        /* Simulation Controls */
        .simulation-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            flex-wrap: wrap;
        }

        .sim-control-buttons {
            display: flex;
            gap: 5px;
        }

        label {
            font-size: 1.1rem;
        }

        input[type="range"] {
            -webkit-appearance: none;
            background: transparent;
            width: 100px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            background: var(--sys-black);
            cursor: pointer;
            margin-top: -6px;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: var(--sys-black);
        }

        /* Info Panel */
        .info-panel {
            font-size: 1rem;
            text-align: center;
            padding: 5px 0 0;
            border-top: 1px dashed var(--sys-black);
        }
        
        /* Retro Modal Styles (Shared for HALT and HELP) */
        .retro-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .retro-modal-window {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            box-shadow: 6px 6px 0px rgba(0,0,0,0.5);
            width: 95%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-content {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
            text-align: center;
        }

        .modal-text {
            font-size: 1.1rem;
            font-weight: bold;
            color: #d90429; /* A retro red for warnings */
            padding: 5px;
            border: 1px dashed var(--sys-black);
            width: 100%;
            box-sizing: border-box;
            text-align: left;
        }

        /* Help Modal Specific Styling */
        .rule-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid var(--sys-grey);
            width: 100%;
            box-sizing: border-box;
            background: #eee;
        }

        .rule-visual {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 1px;
            width: 60px;
            height: 60px;
            border: 1px solid var(--sys-black);
            margin-bottom: 5px;
        }

        .cell {
            border: 1px solid var(--cell-border);
            box-sizing: border-box;
        }

        .alive { background-color: var(--cell-alive); }
        .dead { background-color: var(--cell-dead); }
        .center-cell { 
            grid-column: 2; 
            grid-row: 2; 
            border: 2px solid #ff0000; /* Red border for emphasis */
        }
        .center-cell.alive { background-color: #008800; } /* Green for target cell */
        .center-cell.dead { background-color: #880000; } /* Red outline for target cell */

        /* Responsive */
        @media (max-width: 500px) {
            body { padding: 5px; }
            .btn { font-size: 0.9rem; padding: 4px 6px; }
            .control-group { flex-wrap: wrap; justify-content: center;}
            .simulation-controls { justify-content: center; gap: 10px;}
        }
    </style>
</head>
<body>

<div class="window">
    <div class="title-bar">
        <div class="close-box" onclick="closeModal('halt')"></div>
        <div class="title-lines"></div>
        <span>CELL.LIFE</span>
        <div class="title-lines"></div>
    </div>

    <div class="content">
        <!-- Setup Controls -->
        <div class="toolbar">
            <div class="control-group">
                <span class="control-group-title">SETUP:</span>
                <button class="btn" onclick="clearGrid()">Clear All</button>
                <button class="btn" onclick="randomizeGrid()">Random</button>
            </div>
            
            <div class="control-group">
                <span class="control-group-title">GRID & HELP:</span>
                <select id="grid-size" class="btn" onchange="changeGridSize()">
                    <option value="16">16x16</option>
                    <option value="32">32x32</option>
                    <option value="64">64x64</option>
                </select>
                <button class="btn" onclick="showHelpModal()">[?] HELP</button>
                <button class="btn" onclick="resetSimulation()" style="color:red; font-weight:bold;">RESET</button>
            </div>
        </div>

        <!-- Main Canvas -->
        <div class="canvas-container">
            <canvas id="editorCanvas" width="320" height="320"></canvas>
        </div>

        <!-- Simulation Controls -->
        <div class="simulation-controls">
            <div class="sim-control-buttons">
                <button class="btn" id="play-btn" onclick="toggleSimulation()">&#9658; START</button>
                <button class="btn" id="step-btn" onclick="stepSimulation()">STEP</button>
                <!-- Added Step Back Button -->
                <button class="btn" id="step-back-btn" onclick="stepBack()" disabled>&lt; BACK</button> 
            </div>
            <div style="display:flex; align-items:center; gap:5px;">
                <label>Speed:</label>
                <!-- Range is 1 (Slow) to 20 (Fast) -->
                <input type="range" id="speed-range" min="1" max="20" value="8" oninput="updateSpeed()">
            </div>
        </div>

        <!-- Info Panel / Future Achievement Display -->
        <div class="info-panel">
            Generation: <span id="generation-indicator">0</span> | Population: <span id="population-indicator">0</span>
        </div>
    </div>
</div>

<!-- Modal HTML structure for halting messages -->
<div id="haltModal" class="retro-modal-overlay" style="display: none;">
    <div class="retro-modal-window">
        <div class="title-bar">
            <div class="close-box" onclick="closeModal('halt')"></div>
            <div class="title-lines"></div>
            <span>SIMULATION HALTED</span>
            <div class="title-lines"></div>
        </div>
        <div class="modal-content">
            <p style="font-size: 1.2rem; margin-bottom: 10px;">SYSTEM ALERT:</p>
            <div id="modal-halt-reason" class="modal-text"></div>
            <p>Generation: <span id="modal-halt-generation">0</span></p>
            <p>Population: <span id="modal-halt-population">0</span></p>
            <button class="btn" onclick="closeModal('halt')">OKAY</button>
        </div>
    </div>
</div>

<!-- Modal HTML structure for Help/Rules -->
<div id="helpModal" class="retro-modal-overlay" style="display: none;">
    <div class="retro-modal-window">
        <div class="title-bar">
            <div class="close-box" onclick="closeModal('help')"></div>
            <div class="title-lines"></div>
            <span>CELL.LIFE - RULES GUIDE</span>
            <div class="title-lines"></div>
        </div>
        <div class="modal-content">
            <p style="font-size: 1.2rem; margin-bottom: 5px;">HOW THE GAME WORKS</p>
            <p style="text-align: left; font-size: 0.9rem;">
                This game uses simple rules to create complex patterns. You set up the first pattern by clicking on the grid to make cells ALIVE (black). When you press START, every cell changes based on its 8 neighbors (the cells touching it).
            </p>
            
            <p style="font-size: 1.2rem; margin-top: 10px; margin-bottom: 5px;">THE FOUR SIMPLE RULES</p>

            <!-- Rules will be injected here by JavaScript -->
            <div id="rules-container" style="width: 100%;"></div>

            <button class="btn" onclick="closeModal('help')">I GOT IT</button>
        </div>
    </div>
</div>


<script>
    // --- Configuration ---
    let gridSize = 16;
    const canvasSize = 320; 
    let pixelSize = canvasSize / gridSize;
    
    // --- State ---
    let grid = []; // 2D array: 0=dead, 1=alive
    let generation = 0;
    let population = 0;
    let gridHistory = []; // Stores previous grid states
    const maxHistory = 10; // Only store the last N generations for oscillation check and step back
    
    let isRunning = false;
    let runInterval = null;
    let fps = 8; // Frames (Generations) per second
    let isDrawing = false; // For mouse/touch interaction

    // --- DOM Elements ---
    const canvas = document.getElementById('editorCanvas');
    const ctx = canvas.getContext('2d');
    const playBtn = document.getElementById('play-btn');
    const stepBtn = document.getElementById('step-btn');
    const stepBackBtn = document.getElementById('step-back-btn');
    const genIndicator = document.getElementById('generation-indicator');
    const popIndicator = document.getElementById('population-indicator');
    
    // Halting Modal Elements
    const haltModal = document.getElementById('haltModal');
    const modalHaltReason = document.getElementById('modal-halt-reason');
    const modalHaltGen = document.getElementById('modal-halt-generation');
    const modalHaltPop = document.getElementById('modal-halt-population');

    // Help Modal Elements
    const helpModal = document.getElementById('helpModal');
    const rulesContainer = document.getElementById('rules-container');
    
    // --- Initialization ---
    function init() {
        // Ensure grid settings match current dropdown (default 16x16)
        const select = document.getElementById('grid-size');
        gridSize = parseInt(select.value);
        pixelSize = canvasSize / gridSize;

        grid = createNewGrid(gridSize);
        gridHistory = []; // Ensure history is empty on init
        render();
        updateUI();
        injectRuleVisuals(); // Pre-generate rule visuals
    }

    // --- Grid Logic ---

    /** * Creates and returns a new empty grid (all dead cells) of a specified size. */
    function createNewGrid(size) {
        const newGrid = [];
        for (let y = 0; y < size; y++) {
            let row = [];
            for (let x = 0; x < size; x++) {
                row.push(0);
            }
            newGrid.push(row);
        }
        return newGrid;
    }

    /** Resets the simulation to a clean state. */
    function resetSimulation() {
        if (isRunning) stopSimulation();
        grid = createNewGrid(gridSize);
        generation = 0;
        population = 0;
        gridHistory = []; // Reset history
        render();
        updateUI();
    }

    /** Clears the grid (same as reset, but without stopping simulation if already stopped). */
    function clearGrid() {
        grid = createNewGrid(gridSize);
        generation = 0;
        population = 0;
        gridHistory = []; // Reset history
        render();
        updateUI();
    }

    /** Fills the grid with random living/dead cells. */
    function randomizeGrid() {
        if (isRunning) stopSimulation();
        const newGrid = [];
        for (let y = 0; y < gridSize; y++) {
            let row = [];
            for (let x = 0; x < gridSize; x++) {
                // 30% chance of being alive
                row.push(Math.random() < 0.3 ? 1 : 0);
            }
            newGrid.push(row);
        }
        grid = newGrid;
        generation = 0;
        gridHistory = []; // Clear history after randomization
        updatePopulation(); // Recalculate population after randomization
        render();
        updateUI();
    }

    /** Changes grid size and resets the simulation completely. */
    function changeGridSize() {
        const select = document.getElementById('grid-size');
        const newSize = parseInt(select.value);
        
        if (population > 0 || generation > 0) {
            // Replaced alert with custom function
            if(!confirm("Changing grid size will reset the current pattern and generation count. Continue?")) {
                select.value = gridSize; // Revert selection
                return;
            }
        }
        
        gridSize = newSize;
        pixelSize = canvasSize / gridSize;
        resetSimulation();
    }

    // --- Conway's Game of Life Core Logic ---
    
    /** Counts the number of live neighbors for a cell (x, y) on a specified grid. */
    function countNeighborsForGrid(x, y, targetGrid) {
        let count = 0;
        
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue; 

                // Toroidal/wrapping edges
                const nx = (x + dx + gridSize) % gridSize;
                const ny = (y + dy + gridSize) % gridSize;
                
                count += targetGrid[ny][nx];
            }
        }
        return count;
    }

    /** Calculates the next state of the grid based on Conway's rules, returning the new grid and live count. */
    function calculateNextGeneration(inputGrid) {
        const nextGrid = createNewGrid(gridSize); 
        let liveCount = 0;

        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                const neighbors = countNeighborsForGrid(x, y, inputGrid);
                const state = inputGrid[y][x];

                const isAlive = state === 1;
                let newState = 0;

                if (isAlive && (neighbors === 2 || neighbors === 3)) {
                    newState = 1; // Survival
                } else if (!isAlive && neighbors === 3) {
                    newState = 1; // Reproduction
                }
                
                nextGrid[y][x] = newState;

                if (newState === 1) {
                    liveCount++;
                }
            }
        }
        return { nextGrid, liveCount };
    }
    
    /** Checks for halting conditions (stability, oscillation, extinction, overgrowth). */
    function checkStopConditions(currentGrid, nextGrid, liveCount) {
        const totalCells = gridSize * gridSize;
        let reason = null;

        // 3. Extinction/Overgrowth (Kid-friendly language)
        if (liveCount === 0) {
            reason = "EMPTY! All the cells died. No life left on the grid.";
        } else if (liveCount === totalCells) {
            reason = "FULL HOUSE! The entire grid is full of living cells.";
        }
        
        const currentGridString = JSON.stringify(currentGrid);
        const nextGridString = JSON.stringify(nextGrid);
        
        // 1. Stability (Current grid equals Next grid - Kid-friendly language)
        if (!reason && currentGridString === nextGridString) {
            reason = "STABLE! The pattern is perfectly still and won't change.";
        }
        
        // 2. Oscillation (Next grid equals a recent previous grid in history - Kid-friendly language)
        if (!reason) {
            for (let i = 0; i < gridHistory.length; i++) {
                if (nextGridString === JSON.stringify(gridHistory[i])) {
                    const matchedGen = generation - gridHistory.length + i + 1;
                    reason = `LOOP DETECTED! The pattern is repeating in a circle (State matches Generation ${matchedGen}).`;
                    break;
                }
            }
        }
        
        return reason;
    }


    // --- Drawing Engine ---

    /** Draws the grid lines on the canvas. */
    function drawGridLines() {
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 0; i <= gridSize; i++) {
            ctx.moveTo(i * pixelSize, 0);
            ctx.lineTo(i * pixelSize, canvasSize);
            ctx.moveTo(0, i * pixelSize);
            ctx.lineTo(canvasSize, i * pixelSize);
        }
        ctx.stroke();
    }

    /** Draws a single cell. */
    function drawPixel(x, y, color) {
        ctx.fillStyle = color;
        const gap = 0; 
        ctx.fillRect(x * pixelSize + gap, y * pixelSize + gap, pixelSize - gap*2, pixelSize - gap*2);
    }

    /** Renders the entire grid state to the canvas. */
    function render() {
        ctx.clearRect(0, 0, canvasSize, canvasSize);
        drawGridLines();

        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                if (grid[y][x] === 1) {
                    drawPixel(x, y, '#000'); // Alive cell is Black
                }
            }
        }
    }

    // --- Interaction ---

    /** Converts mouse/touch coordinates to grid coordinates. */
    function getGridCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        const x = Math.floor((clientX - rect.left) / (rect.width / gridSize));
        const y = Math.floor((clientY - rect.top) / (rect.height / gridSize));
        return { x, y };
    }

    /** Toggles the state of a cell on mouse/touch interaction. */
    function handleToggle(e) {
        if (isRunning) return; // Cannot edit while running
        
        const { x, y } = getGridCoords(e);
        if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
            const newState = 1 - grid[y][x]; 
            if (grid[y][x] !== newState) {
                // Save current state before toggle for the first step back
                if (generation === 0 && gridHistory.length === 0) {
                     gridHistory.push(grid.map(row => [...row])); // Save initial state (Gen 0)
                }

                grid[y][x] = newState;
                render();
                updatePopulation();
                updateUI();
            }
        }
        if (e.cancelable) e.preventDefault();
    }

    // Interaction Listeners 
    canvas.addEventListener('mousedown', (e) => { 
        if (!isRunning) handleToggle(e); 
        isDrawing = true; 
    });
    window.addEventListener('mouseup', () => { isDrawing = false; });
    
    canvas.addEventListener('touchstart', (e) => { 
        if (!isRunning) handleToggle(e); 
        isDrawing = true; 
    }, {passive: false});
    canvas.addEventListener('touchend', () => { isDrawing = false; });


    // --- Modal Functions (Shared) ---

    function showHaltModal(reason) {
        modalHaltReason.innerText = reason;
        modalHaltGen.innerText = generation;
        modalHaltPop.innerText = population;
        haltModal.style.display = 'flex';
    }

    function showHelpModal() {
        helpModal.style.display = 'flex';
    }
    
    function closeModal(type) {
        if (type === 'halt') {
            haltModal.style.display = 'none';
        } else if (type === 'help') {
            helpModal.style.display = 'none';
        }
    }

    // --- Help Modal Rule Visuals ---

    /** Generates the HTML for a single rule visual grid.
     * @param {Array<number>} neighborPattern - 8 items representing neighbors (0 or 1). Top-left clockwise.
     * @param {number} centerState - 0 (Dead) or 1 (Alive).
     * @param {string} ruleTitle - Title of the rule.
     * @param {string} ruleText - Kid-friendly explanation.
     * @param {string} resultText - The result of the rule.
     */
    function createRuleVisual(neighborPattern, centerState, ruleTitle, ruleText, resultText) {
        const pattern = [
            neighborPattern[0], neighborPattern[1], neighborPattern[2],
            neighborPattern[7], centerState, neighborPattern[3],
            neighborPattern[6], neighborPattern[5], neighborPattern[4]
        ];

        let html = `
        <div class="rule-section">
            <span style="font-weight: bold; font-size: 1.1rem;">${ruleTitle}</span>
            <div style="display: flex; gap: 15px; align-items: center;">
                <div class="rule-visual">
        `;

        for (let i = 0; i < 9; i++) {
            const state = pattern[i];
            const isCenter = i === 4;
            const stateClass = state === 1 ? 'alive' : 'dead';
            const centerClass = isCenter ? 'center-cell' : '';
            html += `<div class="cell ${stateClass} ${centerClass}"></div>`;
        }

        html += `
                </div>
                <div style="text-align: left; font-size: 0.9rem; max-width: 250px;">
                    <p style="margin: 0;">${ruleText}</p>
                    <p style="margin: 5px 0 0; color: #008800; font-weight: bold;">RESULT: ${resultText}</p>
                </div>
            </div>
        </div>
        `;
        return html;
    }

    function injectRuleVisuals() {
        // Clear old content
        rulesContainer.innerHTML = '';
        
        let visualsHtml = '';
        
        // Rule 1: Underpopulation (Loneliness) - 1 neighbor
        visualsHtml += createRuleVisual(
            [0, 0, 0, 0, 1, 0, 0, 0], // Pattern: 1 neighbor (bottom-right)
            1, // Center is ALIVE
            "RULE 1: LONELINESS (0 or 1 Neighbor)",
            "If an <span style='color:green;'>ALIVE</span> cell has <span style='color:#d90429;'>fewer than 2</span> living neighbors...",
            "The cell <span style='color:#d90429;'>DIES</span>."
        );

        // Rule 2 & 3: Survival (Happy Crowd) - 3 neighbors
        visualsHtml += createRuleVisual(
            [1, 1, 0, 0, 0, 0, 0, 1], // Pattern: 3 neighbors (top-left, top-mid, bottom-left)
            1, // Center is ALIVE
            "RULE 2: SURVIVAL (2 or 3 Neighbors)",
            "If an <span style='color:green;'>ALIVE</span> cell has <span style='color:green;'>exactly 2 or 3</span> living neighbors...",
            "The cell <span style='color:green;'>STAYS ALIVE</span>."
        );
        
        // Rule 4: Overpopulation (Too Crowded) - 4 neighbors
        visualsHtml += createRuleVisual(
            [1, 1, 1, 1, 0, 0, 0, 0], // Pattern: 4 neighbors (top row + right)
            1, // Center is ALIVE
            "RULE 3: CROWDING (4+ Neighbors)",
            "If an <span style='color:green;'>ALIVE</span> cell has <span style='color:#d90429;'>more than 3</span> living neighbors...",
            "The cell <span style='color:#d90429;'>DIES</span>."
        );

        // Rule 5: Reproduction (New Birth) - 3 neighbors
        visualsHtml += createRuleVisual(
            [1, 1, 1, 0, 0, 0, 0, 0], // Pattern: 3 neighbors (top row)
            0, // Center is DEAD
            "RULE 4: NEW BIRTH (Exactly 3 Neighbors)",
            "If a <span style='color:#d90429;'>DEAD</span> cell has <span style='color:green;'>exactly 3</span> living neighbors...",
            "The cell <span style='color:green;'>COMES TO LIFE</span>."
        );
        
        rulesContainer.innerHTML = visualsHtml;
    }


    // --- Simulation Controls ---

    /** Toggles the continuous simulation loop. */
    function toggleSimulation() {
        if (isRunning) stopSimulation();
        else startSimulation();
    }

    /** Starts the continuous simulation loop. */
    function startSimulation() {
        if (population === 0 && generation === 0) {
            if (gridSize > 0 && !confirm("The grid is empty! Start with a random pattern?")) {
                return;
            }
            randomizeGrid();
        }

        isRunning = true;
        playBtn.innerHTML = '&#9632; STOP';
        stepBtn.disabled = true;
        stepBackBtn.disabled = true;
        canvas.style.cursor = 'default';
        document.getElementById('grid-size').disabled = true;

        runInterval = setInterval(() => {
            stepSimulation();
        }, 1000 / fps);
    }

    /** Stops the continuous simulation loop. */
    function stopSimulation() {
        isRunning = false;
        clearInterval(runInterval);
        playBtn.innerHTML = '&#9658; START';
        stepBtn.disabled = false;
        canvas.style.cursor = 'crosshair';
        document.getElementById('grid-size').disabled = false;
    }

    /** Executes one generation step. */
    function stepSimulation() {
        // 1. Store current state for history/stepBack
        const currentGridClone = grid.map(row => [...row]); 
        
        // 2. Calculate next state
        const { nextGrid, liveCount } = calculateNextGeneration(currentGridClone);

        // 3. Check for stopping condition against the new state
        const haltReason = checkStopConditions(currentGridClone, nextGrid, liveCount);
        
        // 4. Store the current grid BEFORE moving to the next one
        gridHistory.push(currentGridClone);
        if (gridHistory.length > maxHistory) {
            gridHistory.shift();
        }

        // 5. Update global state to the next generation
        grid = nextGrid;
        population = liveCount;
        generation++;

        // 6. Render and update UI
        render();
        updateUI();

        // 7. Halt if a reason was found
        if (haltReason) {
            stopSimulation();
            showHaltModal(haltReason);
        }
    }
    
    /** Executes one generation step backward. */
    function stepBack() {
        if (isRunning) stopSimulation();
        
        if (gridHistory.length > 1) { 
            grid = gridHistory.pop(); 
            generation--;
            updatePopulation(); 
            render();
            updateUI();
        } else if (gridHistory.length === 1) {
             grid = gridHistory[0];
             gridHistory = []; 
             generation = 0;
             updatePopulation();
             render();
             updateUI();
        }
    }


    /** Updates the FPS based on the slider, and restarts interval if running. */
    function updateSpeed() {
        const slider = document.getElementById('speed-range');
        fps = parseInt(slider.value);
        if (isRunning) {
            stopSimulation();
            startSimulation(); // Restart with new speed
        }
    }

    /** Recalculates the current population count. */
    function updatePopulation() {
        let count = 0;
        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                if (grid[y][x] === 1) count++;
            }
        }
        population = count;
    }

    // --- UI Update ---

    /** Updates the generation and population displays. */
    function updateUI() {
        genIndicator.innerText = generation;
        popIndicator.innerText = population;

        // Enable/Disable step button based on running state
        stepBtn.disabled = isRunning;
        
        // Enable/Disable step back button based on history size
        stepBackBtn.disabled = isRunning || gridHistory.length <= 1;
    }

    // --- Start ---
    window.onload = function() {
        init();
    }
</script>

</body>
</html>
