<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>System 6 - CELL.LIFE</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    
    <style>
        /* --- System 6 Theme Styles --- */
        :root {
            --sys-black: #000;
            --sys-white: #fff;
            --sys-grey: #aaa; 
            --shadow: 2px 2px 0px var(--sys-black);
            --cell-alive: #000;
            --cell-dead: #fff;
            --cell-border: #999;
        }

        body {
            font-family: 'VT323', monospace;
            background-color: #f0f0f0;
            /* Retro background pattern */
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), 
                              linear-gradient(-45deg, #ccc 25%, transparent 25%), 
                              linear-gradient(45deg, transparent 75%, #ccc 75%), 
                              linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 4px 4px;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            color: var(--sys-black);
            user-select: none;
            -webkit-user-select: none;
        }

        /* The Main Window */
        .window {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            box-shadow: 4px 4px 0px rgba(0,0,0,0.2);
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            margin-bottom: 20px;
        }

        /* Title Bar */
        .title-bar {
            background: var(--sys-black);
            color: var(--sys-white);
            padding: 4px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--sys-black);
            font-size: 1.2rem;
            letter-spacing: 1px;
        }
        
        .title-lines {
            flex-grow: 1;
            height: 12px;
            margin: 0 10px;
            background: repeating-linear-gradient(
                to bottom,
                var(--sys-white),
                var(--sys-white) 1px,
                var(--sys-black) 1px,
                var(--sys-black) 2px
            );
        }

        .close-box {
            width: 12px;
            height: 12px;
            background: var(--sys-white);
            border: 1px solid var(--sys-white);
            box-shadow: inset 1px 1px 0 #000;
            cursor: pointer;
        }

        /* --- New Menu Bar Styles --- */
        .menu-bar {
            display: flex;
            background: var(--sys-grey);
            border-bottom: 2px solid var(--sys-black);
            font-size: 1.1rem;
            padding: 2px 0;
            z-index: 10;
            flex-wrap: wrap;
        }

        .menu-item {
            position: relative;
            padding: 2px 10px;
            cursor: pointer;
            border-right: 1px solid var(--sys-black);
            white-space: nowrap;
        }
        
        .menu-item:hover {
            background: var(--sys-black);
            color: var(--sys-white);
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            box-shadow: 4px 4px 0px rgba(0,0,0,0.2);
            padding: 5px;
            min-width: 150px;
            z-index: 100;
            flex-direction: column;
            gap: 5px;
        }

        .menu-item:hover .dropdown-content {
            display: flex;
        }
        
        /* Dropdown Buttons/Controls */
        .dropdown-content button, .dropdown-content select, .dropdown-content label {
            width: 100%;
            text-align: left;
            background: var(--sys-white);
            border: none;
            padding: 5px;
            font-family: 'VT323', monospace;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: none;
            transition: background 0.1s;
            color: var(--sys-black);
            border: 1px solid transparent;
        }
        .dropdown-content button:hover, .dropdown-content select:focus {
            background: var(--sys-black);
            color: var(--sys-white);
        }
        .dropdown-content button:active {
            transform: none;
            box-shadow: none;
        }
        .dropdown-content select {
            border: 1px solid var(--sys-black);
            box-sizing: border-box;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        .dropdown-content label {
            padding: 0 5px;
            font-weight: bold;
        }
        
        .menu-divider {
            height: 1px;
            background: var(--sys-black);
            margin: 5px 0;
            width: 100%;
        }


        /* Main Content Area */
        .content {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* Canvas Area */
        .canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            background: #e0e0e0;
            padding: 10px;
            border: 1px inset var(--sys-black);
        }

        canvas {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            cursor: crosshair;
            image-rendering: pixelated;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            
            /* Responsive resizing */
            width: 100%;
            height: auto;
            max-width: 320px; /* Limit max size */
            aspect-ratio: 1 / 1; 
            touch-action: none; /* Prevents scrolling when interacting with the grid */
        }

        /* Simulation Controls */
        .simulation-controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .control-group-row {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .btn {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            padding: 5px 10px;
            font-family: 'VT323', monospace;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 2px 2px 0px var(--sys-black);
            transition: transform 0.1s;
            text-transform: uppercase;
            text-decoration: none;
            color: var(--sys-black);
            display: inline-block;
            text-align: center;
        }

        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: none;
            background: var(--sys-black);
            color: var(--sys-white);
        }

        .btn:disabled {
            color: #aaa;
            border-color: #aaa;
            box-shadow: none;
            cursor: default;
        }
        
        .speed-control-container {
            align-items: center;
        }

        label {
            font-size: 1.1rem;
        }

        input[type="range"] {
            -webkit-appearance: none;
            background: transparent;
            width: 100px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            background: var(--sys-black);
            cursor: pointer;
            margin-top: -6px;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: var(--sys-black);
        }

        /* Info Panel */
        .info-panel {
            font-size: 1rem;
            text-align: center;
            padding: 5px 0 0;
            border-top: 1px dashed var(--sys-black);
        }
        
        /* Retro Modal Styles (Shared for HALT and HELP) */
        .retro-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .retro-modal-window {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            box-shadow: 6px 6px 0px rgba(0,0,0,0.5);
            width: 95%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-content {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
            text-align: center;
        }

        .modal-text {
            font-size: 1.1rem;
            font-weight: bold;
            color: #d90429; /* A retro red for warnings */
            padding: 5px;
            border: 1px dashed var(--sys-black);
            width: 100%;
            box-sizing: border-box;
            text-align: left;
        }

        /* Help Modal Specific Styling */
        .rule-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid var(--sys-grey);
            width: 100%;
            box-sizing: border-box;
            background: #eee;
        }

        .rule-visual {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 1px;
            width: 60px;
            height: 60px;
            border: 1px solid var(--sys-black);
            margin-bottom: 5px;
        }

        .cell {
            border: 1px solid var(--cell-border);
            box-sizing: border-box;
        }

        .alive { background-color: var(--cell-alive); }
        .dead { background-color: var(--cell-dead); }
        .center-cell { 
            grid-column: 2; 
            grid-row: 2; 
            border: 2px solid #ff0000; /* Red border for emphasis */
        }
        .center-cell.alive { background-color: #008800; } /* Green for target cell */
        .center-cell.dead { background-color: #880000; } /* Red outline for target cell */

        /* Responsive */
        @media (max-width: 500px) {
            body { padding: 5px; }
            .btn { font-size: 0.9rem; padding: 4px 6px; }
            .control-group-row { justify-content: center;}
            .menu-bar { justify-content: center; }
        }
    </style>
</head>
<body>

<div class="window">
    <div class="title-bar">
        <div class="close-box" onclick="closeModal('halt')"></div>
        <div class="title-lines"></div>
        <span>CELL.LIFE</span>
        <div class="title-lines"></div>
    </div>
    
    <!-- NEW MENU BAR -->
    <nav class="menu-bar">
        <div class="menu-item">FILE
            <div class="dropdown-content">
                <button onclick="resetSimulation()">[?] Reset All</button>
                <button onclick="showHelpModal()">[?] Help/Rules</button>
                <div class="menu-divider"></div>
                <label for="grid-size">Grid Size:</label>
                <select id="grid-size" onchange="changeGridSize()">
                    <option value="16">16x16</option>
                    <option value="32">32x32</option>
                    <option value="64">64x64</option>
                </select>
            </div>
        </div>
        
        <div class="menu-item">EDIT
            <div class="dropdown-content">
                <button onclick="clearGrid()">Clear Grid</button>
                <button onclick="randomizeGrid()">Randomize</button>
            </div>
        </div>
        
        <div class="menu-item">PATTERNS
            <div class="dropdown-content">
                <select id="pattern-selector" onchange="loadSelectedPattern()">
                    <option value="">-- Load a Pattern --</option>
                    <optgroup label="Still Lifes (Stable)">
                        <option value="block">Block</option>
                        <option value="beehive">Beehive</option>
                        <option value="boat">Boat</option>
                    </optgroup>
                    <optgroup label="Oscillators (Repeating)">
                        <option value="blinker">Blinker</option>
                        <option value="toad">Toad</option>
                        <option value="pulsar">Pulsar (Needs 32x32+)</option>
                    </optgroup>
                    <optgroup label="Spaceships (Moving)">
                        <option value="glider">Glider (The Classic)</option>
                        <option value="lwss">Lightweight Spaceship</option>
                    </optgroup>
                </select>
            </div>
        </div>
    </nav>
    <!-- END MENU BAR -->


    <div class="content">
        <!-- Main Canvas -->
        <div class="canvas-container">
            <canvas id="editorCanvas" width="320" height="320"></canvas>
        </div>

        <!-- Simulation Controls -->
        <div class="simulation-controls">
            <div class="control-group-row">
                <!-- Buttons for the two running modes. Start(true) halts, Start(false) runs forever -->
                <button class="btn" id="run-halting-btn" onclick="startSimulation(true)">&#9658; START (One Run)</button>
                <button class="btn" id="run-forever-btn" onclick="startSimulation(false)">&#9658; RUN FOREVER</button>
                <button class="btn" id="stop-btn" onclick="stopSimulation()" style="display:none; background: #d90429; color: white; font-weight:bold;">&#9632; STOP</button>
            </div>
            
            <div class="control-group-row">
                <button class="btn" id="step-btn" onclick="stepSimulation()">STEP</button>
                <button class="btn" id="step-back-btn" onclick="stepBack()" disabled>&lt; BACK</button> 
            </div>

            <div class="control-group-row speed-control-container">
                <label>Speed:</label>
                <!-- Range is 1 (Slow) to 20 (Fast) -->
                <input type="range" id="speed-range" min="1" max="20" value="8" oninput="updateSpeed()">
            </div>
        </div>

        <!-- Info Panel / Future Achievement Display -->
        <div class="info-panel">
            Generation: <span id="generation-indicator">0</span> | Population: <span id="population-indicator">0</span>
        </div>
    </div>
</div>

<!-- Modal HTML structure for halting messages -->
<div id="haltModal" class="retro-modal-overlay" style="display: none;">
    <div class="retro-modal-window">
        <div class="title-bar">
            <div class="close-box" onclick="closeModal('halt')"></div>
            <div class="title-lines"></div>
            <span>SIMULATION HALTED</span>
            <div class="title-lines"></div>
        </div>
        <div class="modal-content">
            <p style="font-size: 1.2rem; margin-bottom: 10px;">SYSTEM ALERT:</p>
            <div id="modal-halt-reason" class="modal-text"></div>
            <p>Generation: <span id="modal-halt-generation">0</span></p>
            <p>Population: <span id="modal-halt-population">0</span></p>
            <button class="btn" onclick="closeModal('halt')">OKAY</button>
        </div>
    </div>
</div>

<!-- Modal HTML structure for Help/Rules -->
<div id="helpModal" class="retro-modal-overlay" style="display: none;">
    <div class="retro-modal-window">
        <div class="title-bar">
            <div class="close-box" onclick="closeModal('help')"></div>
            <div class="title-lines"></div>
            <span>CELL.LIFE - RULES GUIDE</span>
            <div class="title-lines"></div>
        </div>
        <div class="modal-content">
            <p style="font-size: 1.2rem; margin-bottom: 5px;">HOW THE GAME WORKS</p>
            <p style="text-align: left; font-size: 0.9rem;">
                This game uses simple rules to create complex patterns. You set up the first pattern by clicking on the grid to make cells ALIVE (black). When you press START, every cell changes based on its 8 neighbors (the cells touching it).
            </p>
            
            <p style="font-size: 1.2rem; margin-top: 10px; margin-bottom: 5px;">THE FOUR SIMPLE RULES</p>

            <!-- Rules will be injected here by JavaScript -->
            <div id="rules-container" style="width: 100%;"></div>

            <button class="btn" onclick="closeModal('help')">I GOT IT</button>
        </div>
    </div>
</div>


<script>
    // --- Configuration ---
    let gridSize = 16;
    const canvasSize = 320; 
    let pixelSize = canvasSize / gridSize;
    
    // --- State ---
    let grid = []; // 2D array: 0=dead, 1=alive
    let generation = 0;
    let population = 0;
    let gridHistory = []; // Stores previous grid states
    const maxHistory = 10; // Only store the last N generations for oscillation check and step back
    
    let isRunning = false;
    let isHaltingEnabled = true; // NEW: Controls whether stop conditions are checked
    let runInterval = null;
    let fps = 8; // Frames (Generations) per second
    let isDrawing = false; // For mouse/touch interaction

    // --- DOM Elements ---
    const canvas = document.getElementById('editorCanvas');
    const ctx = canvas.getContext('2d');
    const runHaltingBtn = document.getElementById('run-halting-btn');
    const runForeverBtn = document.getElementById('run-forever-btn');
    const stopBtn = document.getElementById('stop-btn');
    const stepBtn = document.getElementById('step-btn');
    const stepBackBtn = document.getElementById('step-back-btn');
    const genIndicator = document.getElementById('generation-indicator');
    const popIndicator = document.getElementById('population-indicator');
    
    // Halting Modal Elements
    const haltModal = document.getElementById('haltModal');
    const modalHaltReason = document.getElementById('modal-halt-reason');
    const modalHaltGen = document.getElementById('modal-halt-generation');
    const modalHaltPop = document.getElementById('modal-halt-population');

    // Help Modal Elements
    const helpModal = document.getElementById('helpModal');
    const rulesContainer = document.getElementById('rules-container');
    
    // --- Pattern Definitions ---
    // Patterns are defined as a list of relative (x, y) coordinates for live cells, 
    // where (0, 0) is the top-left corner of the pattern's bounding box.
    const PATTERNS = {
        // Still Lifes (Stable)
        block: [[0, 0], [1, 0], [0, 1], [1, 1]], // 2x2
        beehive: [[1, 0], [2, 0], [0, 1], [3, 1], [1, 2], [2, 2]], // 4x3
        boat: [[0, 0], [1, 0], [0, 1], [2, 1], [1, 2]], // 3x3
        
        // Oscillators (Repeating)
        blinker: [[0, 1], [1, 1], [2, 1]], // 3x1 (period 2)
        toad: [[1, 0], [2, 0], [3, 0], [0, 1], [1, 1], [2, 1]], // 4x2 (period 2)
        pulsar: [ // 13x13 (period 3) - needs space
            [2, 0], [3, 0], [4, 0], [8, 0], [9, 0], [10, 0],
            [0, 2], [5, 2], [7, 2], [12, 2],
            [0, 3], [5, 3], [7, 3], [12, 3],
            [0, 4], [5, 4], [7, 4], [12, 4],
            [2, 5], [3, 5], [4, 5], [8, 5], [9, 5], [10, 5],
            [2, 7], [3, 7], [4, 7], [8, 7], [9, 7], [10, 7],
            [0, 8], [5, 8], [7, 8], [12, 8],
            [0, 9], [5, 9], [7, 9], [12, 9],
            [0, 10], [5, 10], [7, 10], [12, 10],
            [2, 12], [3, 12], [4, 12], [8, 12], [9, 12], [10, 12]
        ],
        
        // Spaceships (Moving)
        glider: [[1, 0], [2, 1], [0, 2], [1, 2], [2, 2]], // 3x3
        lwss: [ // Lightweight Spaceship (LWSS) 5x4
            [1, 0], [4, 0],
            [0, 1], [0, 2], [4, 2],
            [0, 3], [1, 3], [2, 3], [3, 3]
        ]
    };

    // --- Initialization ---
    function init() {
        // Ensure grid settings match current dropdown (default 16x16)
        const select = document.getElementById('grid-size');
        gridSize = parseInt(select.value);
        pixelSize = canvasSize / gridSize;

        grid = createNewGrid(gridSize);
        gridHistory = []; // Ensure history is empty on init
        render();
        updateUI();
        injectRuleVisuals(); // Pre-generate rule visuals
    }

    // --- Grid Logic ---

    /** * Creates and returns a new empty grid (all dead cells) of a specified size. */
    function createNewGrid(size) {
        const newGrid = [];
        for (let y = 0; y < size; y++) {
            let row = [];
            for (let x = 0; x < size; x++) {
                row.push(0);
            }
            newGrid.push(row);
        }
        return newGrid;
    }

    /** Resets the simulation to a clean state. */
    function resetSimulation() {
        if (isRunning) stopSimulation();
        grid = createNewGrid(gridSize);
        generation = 0;
        population = 0;
        gridHistory = []; // Reset history
        render();
        updateUI();
        document.getElementById('pattern-selector').value = ""; // Reset pattern selector
    }

    /** Clears the grid (same as reset, but without stopping simulation if already stopped). */
    function clearGrid() {
        grid = createNewGrid(gridSize);
        generation = 0;
        population = 0;
        gridHistory = []; // Reset history
        render();
        updateUI();
        document.getElementById('pattern-selector').value = "";
    }

    /** Fills the grid with random living/dead cells. */
    function randomizeGrid() {
        if (isRunning) stopSimulation();
        const newGrid = [];
        for (let y = 0; y < gridSize; y++) {
            let row = [];
            for (let x = 0; x < gridSize; x++) {
                // 30% chance of being alive
                row.push(Math.random() < 0.3 ? 1 : 0);
            }
            newGrid.push(row);
        }
        grid = newGrid;
        generation = 0;
        gridHistory = []; // Clear history after randomization
        updatePopulation(); // Recalculate population after randomization
        render();
        updateUI();
        document.getElementById('pattern-selector').value = "";
    }

    /** Changes grid size and resets the simulation completely. */
    function changeGridSize() {
        const select = document.getElementById('grid-size');
        const newSize = parseInt(select.value);
        
        if (population > 0 || generation > 0) {
            // Revert selection if user cancels confirmation
            const confirmed = confirm("Changing grid size will reset the current pattern and generation count. Continue?");
            if (!confirmed) {
                select.value = gridSize; 
                return;
            }
        }
        
        gridSize = newSize;
        pixelSize = canvasSize / gridSize;
        resetSimulation();
    }

    /** Loads a pattern onto the grid. */
    function loadSelectedPattern() {
        const selector = document.getElementById('pattern-selector');
        const patternKey = selector.value;

        if (!patternKey || !PATTERNS[patternKey]) return;

        // Stop simulation and clear grid before loading new pattern
        if (isRunning) stopSimulation();
        clearGrid();

        const pattern = PATTERNS[patternKey];
        
        // Find bounding box to center the pattern
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        pattern.forEach(([x, y]) => {
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
        });

        const patternWidth = maxX - minX + 1;
        const patternHeight = maxY - minY + 1;
        
        // Check if pattern fits
        if (patternWidth > gridSize || patternHeight > gridSize) {
             // Reset selector value
             selector.value = "";
             // Use custom modal instead of alert for better UI
             showHaltModal(`Pattern "${patternKey}" is too large for the current ${gridSize}x${gridSize} grid. Try switching to 32x32 or 64x64.`, 'Pattern Load Error');
             return;
        }

        // Calculate offset to center the pattern
        const offsetX = Math.floor((gridSize - patternWidth) / 2) - minX;
        const offsetY = Math.floor((gridSize - patternHeight) / 2) - minY;

        // Apply pattern
        // We ensure grid is a fresh start before applying the pattern
        grid = createNewGrid(gridSize);
        pattern.forEach(([x, y]) => {
            const finalX = x + offsetX;
            const finalY = y + offsetY;
            if (finalX >= 0 && finalX < gridSize && finalY >= 0 && finalY < gridSize) {
                 grid[finalY][finalX] = 1;
            }
        });

        // Set initial state for stepBack
        gridHistory.push(grid.map(row => [...row])); 
        generation = 0;
        updatePopulation();
        render();
        updateUI();
    }


    // --- Conway's Game of Life Core Logic ---
    
    /** Counts the number of live neighbors for a cell (x, y) on a specified grid. */
    function countNeighborsForGrid(x, y, targetGrid) {
        let count = 0;
        
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue; 

                // Toroidal/wrapping edges
                const nx = (x + dx + gridSize) % gridSize;
                const ny = (y + dy + gridSize) % gridSize;
                
                count += targetGrid[ny][nx];
            }
        }
        return count;
    }

    /** Calculates the next state of the grid based on Conway's rules, returning the new grid and live count. */
    function calculateNextGeneration(inputGrid) {
        const nextGrid = createNewGrid(gridSize); 
        let liveCount = 0;

        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                const neighbors = countNeighborsForGrid(x, y, inputGrid);
                const state = inputGrid[y][x];

                const isAlive = state === 1;
                let newState = 0;

                if (isAlive && (neighbors === 2 || neighbors === 3)) {
                    newState = 1; // Survival
                } else if (!isAlive && neighbors === 3) {
                    newState = 1; // Reproduction
                }
                
                nextGrid[y][x] = newState;

                if (newState === 1) {
                    liveCount++;
                }
            }
        }
        return { nextGrid, liveCount };
    }
    
    /** Checks for halting conditions (stability, oscillation, extinction, overgrowth). */
    function checkStopConditions(currentGrid, nextGrid, liveCount) {
        const totalCells = gridSize * gridSize;
        let reason = null;

        // 3. Extinction/Overgrowth
        if (liveCount === 0) {
            reason = "EMPTY! All the cells died. No life left on the grid.";
        } else if (liveCount === totalCells) {
            reason = "FULL HOUSE! The entire grid is full of living cells.";
        }
        
        const currentGridString = JSON.stringify(currentGrid);
        const nextGridString = JSON.stringify(nextGrid);
        
        // 1. Stability 
        if (!reason && currentGridString === nextGridString) {
            reason = "STABLE! The pattern is perfectly still and won't change.";
        }
        
        // 2. Oscillation 
        if (!reason) {
            for (let i = 0; i < gridHistory.length; i++) {
                if (nextGridString === JSON.stringify(gridHistory[i])) {
                    const matchedGen = generation - gridHistory.length + i + 1;
                    reason = `LOOP DETECTED! The pattern is repeating in a circle (State matches Generation ${matchedGen}).`;
                    break;
                }
            }
        }
        
        return reason;
    }


    // --- Drawing Engine ---

    /** Draws the grid lines on the canvas. */
    function drawGridLines() {
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 0; i <= gridSize; i++) {
            ctx.moveTo(i * pixelSize, 0);
            ctx.lineTo(i * pixelSize, canvasSize);
            ctx.moveTo(0, i * pixelSize);
            ctx.lineTo(canvasSize, i * pixelSize);
        }
        ctx.stroke();
    }

    /** Draws a single cell. */
    function drawPixel(x, y, color) {
        ctx.fillStyle = color;
        const gap = 0; 
        ctx.fillRect(x * pixelSize + gap, y * pixelSize + gap, pixelSize - gap*2, pixelSize - gap*2);
    }

    /** Renders the entire grid state to the canvas. */
    function render() {
        ctx.clearRect(0, 0, canvasSize, canvasSize);
        drawGridLines();

        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                if (grid[y][x] === 1) {
                    drawPixel(x, y, '#000'); // Alive cell is Black
                }
            }
        }
    }

    // --- Interaction ---

    /** Converts mouse/touch coordinates to grid coordinates. */
    function getGridCoords(e) {
        const rect = canvas.getBoundingClientRect();
        // Use offset from touch or mouse event
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        const x = Math.floor((clientX - rect.left) / (rect.width / gridSize));
        const y = Math.floor((clientY - rect.top) / (rect.height / gridSize));
        return { x, y };
    }

    /** Toggles the state of a cell on mouse/touch interaction. */
    function handleToggle(e) {
        if (isRunning) return; // Cannot edit while running
        
        const { x, y } = getGridCoords(e);
        if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
            const newState = 1 - grid[y][x]; 
            if (grid[y][x] !== newState) {
                // Save current state before toggle for the first step back
                if (generation === 0 && gridHistory.length === 0) {
                     gridHistory.push(grid.map(row => [...row])); // Save initial state (Gen 0)
                }

                grid[y][x] = newState;
                render();
                updatePopulation();
                updateUI();
            }
        }
        if (e.cancelable) e.preventDefault();
    }

    // Interaction Listeners 
    canvas.addEventListener('mousedown', (e) => { 
        if (!isRunning) handleToggle(e); 
        isDrawing = true; 
    });
    window.addEventListener('mouseup', () => { isDrawing = false; });
    
    canvas.addEventListener('touchstart', (e) => { 
        if (!isRunning) handleToggle(e); 
        isDrawing = true; 
    }, {passive: false});
    canvas.addEventListener('touchend', () => { isDrawing = false; });


    // --- Modal Functions (Shared) ---

    /** Shows the halt modal with a specific message. */
    function showHaltModal(reason, title = 'SIMULATION HALTED') {
        // Update the modal title bar (using JS for simplicity over separate modal components)
        document.querySelector('#haltModal .title-bar span').innerText = title;
        
        modalHaltReason.innerText = reason;
        modalHaltGen.innerText = generation;
        modalHaltPop.innerText = population;
        haltModal.style.display = 'flex';
    }

    function showHelpModal() {
        helpModal.style.display = 'flex';
    }
    
    function closeModal(type) {
        if (type === 'halt') {
            haltModal.style.display = 'none';
            // Restore default title bar text
            document.querySelector('#haltModal .title-bar span').innerText = 'SIMULATION HALTED';
        } else if (type === 'help') {
            helpModal.style.display = 'none';
        }
    }

    // --- Help Modal Rule Visuals ---

    /** Creates the HTML for a rule visual (same as before) */
    function createRuleVisual(neighborPattern, centerState, ruleTitle, ruleText, resultText) {
        const pattern = [
            neighborPattern[0], neighborPattern[1], neighborPattern[2],
            neighborPattern[7], centerState, neighborPattern[3],
            neighborPattern[6], neighborPattern[5], neighborPattern[4]
        ];

        let html = `
        <div class="rule-section">
            <span style="font-weight: bold; font-size: 1.1rem;">${ruleTitle}</span>
            <div style="display: flex; gap: 15px; align-items: center;">
                <div class="rule-visual">
        `;

        for (let i = 0; i < 9; i++) {
            const state = pattern[i];
            const isCenter = i === 4;
            const stateClass = state === 1 ? 'alive' : 'dead';
            const centerClass = isCenter ? 'center-cell' : '';
            html += `<div class="cell ${stateClass} ${centerClass}"></div>`;
        }

        html += `
                </div>
                <div style="text-align: left; font-size: 0.9rem; max-width: 250px;">
                    <p style="margin: 0;">${ruleText}</p>
                    <p style="margin: 5px 0 0; color: #008800; font-weight: bold;">RESULT: ${resultText}</p>
                </div>
            </div>
        </div>
        `;
        return html;
    }

    function injectRuleVisuals() {
        // Clear old content
        rulesContainer.innerHTML = '';
        
        let visualsHtml = '';
        
        // Rule 1: Underpopulation (Loneliness) - 1 neighbor
        visualsHtml += createRuleVisual(
            [0, 0, 0, 0, 1, 0, 0, 0], // Pattern: 1 neighbor (bottom-right)
            1, // Center is ALIVE
            "RULE 1: LONELINESS (0 or 1 Neighbor)",
            "If an <span style='color:green;'>ALIVE</span> cell has <span style='color:#d90429;'>fewer than 2</span> living neighbors...",
            "The cell <span style='color:#d90429;'>DIES</span>."
        );

        // Rule 2 & 3: Survival (Happy Crowd) - 3 neighbors
        visualsHtml += createRuleVisual(
            [1, 1, 0, 0, 0, 0, 0, 1], // Pattern: 3 neighbors (top-left, top-mid, bottom-left)
            1, // Center is ALIVE
            "RULE 2: SURVIVAL (2 or 3 Neighbors)",
            "If an <span style='color:green;'>ALIVE</span> cell has <span style='color:green;'>exactly 2 or 3</span> living neighbors...",
            "The cell <span style='color:green;'>STAYS ALIVE</span>."
        );
        
        // Rule 4: Overpopulation (Too Crowded) - 4 neighbors
        visualsHtml += createRuleVisual(
            [1, 1, 1, 1, 0, 0, 0, 0], // Pattern: 4 neighbors (top row + right)
            1, // Center is ALIVE
            "RULE 3: CROWDING (4+ Neighbors)",
            "If an <span style='color:green;'>ALIVE</span> cell has <span style='color:#d90429;'>more than 3</span> living neighbors...",
            "The cell <span style='color:#d90429;'>DIES</span>."
        );

        // Rule 5: Reproduction (New Birth) - 3 neighbors
        visualsHtml += createRuleVisual(
            [1, 1, 1, 0, 0, 0, 0, 0], // Pattern: 3 neighbors (top row)
            0, // Center is DEAD
            "RULE 4: NEW BIRTH (Exactly 3 Neighbors)",
            "If a <span style='color:#d90429;'>DEAD</span> cell has <span style='color:green;'>exactly 3</span> living neighbors...",
            "The cell <span style='color:green;'>COMES TO LIFE</span>."
        );
        
        rulesContainer.innerHTML = visualsHtml;
    }


    // --- Simulation Controls ---

    /** * Starts the continuous simulation loop. 
     * @param {boolean} shouldHalt - If true, checks for stability/oscillation and halts. If false, runs forever.
     */
    function startSimulation(shouldHalt) {
        if (isRunning) stopSimulation();

        // Check for empty grid logic...
        if (population === 0 && generation === 0) {
            const confirmed = confirm("The grid is empty! Start with a random pattern?");
            if (!confirmed) {
                return;
            }
            randomizeGrid();
        }

        isHaltingEnabled = shouldHalt;
        isRunning = true;
        
        // UI updates for running state
        runHaltingBtn.style.display = 'none';
        runForeverBtn.style.display = 'none';
        stopBtn.style.display = 'inline-block';
        
        stepBtn.disabled = true;
        stepBackBtn.disabled = true;
        canvas.style.cursor = 'default';
        document.getElementById('grid-size').disabled = true;
        document.getElementById('pattern-selector').disabled = true;


        runInterval = setInterval(() => {
            stepSimulation();
        }, 1000 / fps);
    }

    /** Stops the continuous simulation loop. */
    function stopSimulation() {
        isRunning = false;
        clearInterval(runInterval);
        
        // UI updates for stopped state
        runHaltingBtn.style.display = 'inline-block';
        runForeverBtn.style.display = 'inline-block';
        stopBtn.style.display = 'none';

        stepBtn.disabled = false;
        canvas.style.cursor = 'crosshair';
        document.getElementById('grid-size').disabled = false;
        document.getElementById('pattern-selector').disabled = false;
        updateUI(); // To update the stepBack button state
    }

    /** Executes one generation step. */
    function stepSimulation() {
        // 1. Store current state for history/stepBack
        const currentGridClone = grid.map(row => [...row]); 
        
        // 2. Calculate next state
        const { nextGrid, liveCount } = calculateNextGeneration(currentGridClone);

        // 3. Check for stopping condition against the new state (only if halting is enabled)
        let haltReason = null;
        if (isHaltingEnabled) {
            haltReason = checkStopConditions(currentGridClone, nextGrid, liveCount);
        }
        
        // 4. Store the current grid BEFORE moving to the next one
        gridHistory.push(currentGridClone);
        if (gridHistory.length > maxHistory) {
            gridHistory.shift();
        }

        // 5. Update global state to the next generation
        grid = nextGrid;
        population = liveCount;
        generation++;

        // 6. Render and update UI
        render();
        updateUI();

        // 7. Halt if a reason was found
        if (haltReason) {
            stopSimulation();
            showHaltModal(haltReason);
        }
    }
    
    /** Executes one generation step backward. */
    function stepBack() {
        if (isRunning) stopSimulation();
        
        if (gridHistory.length > 1) { 
            grid = gridHistory.pop(); 
            generation--;
            updatePopulation(); 
            render();
            updateUI();
        } else if (gridHistory.length === 1) {
             grid = gridHistory.pop(); // Pop the last state (Gen 0)
             generation = 0;
             updatePopulation();
             render();
             updateUI();
        }
    }


    /** Updates the FPS based on the slider, and restarts interval if running. */
    function updateSpeed() {
        const slider = document.getElementById('speed-range');
        fps = parseInt(slider.value);
        if (isRunning) {
            // Stop and restart to apply new speed without halting check changing
            const wasHalting = isHaltingEnabled;
            stopSimulation();
            startSimulation(wasHalting); 
        }
    }

    /** Recalculates the current population count. */
    function updatePopulation() {
        let count = 0;
        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                if (grid[y][x] === 1) count++;
            }
        }
        population = count;
    }

    // --- UI Update ---

    /** Updates the generation and population displays. */
    function updateUI() {
        genIndicator.innerText = generation;
        popIndicator.innerText = population;

        // Step and Step Back controls should only be enabled when not running.
        stepBtn.disabled = isRunning;
        stepBackBtn.disabled = isRunning || gridHistory.length === 0;
        document.getElementById('pattern-selector').disabled = isRunning;
    }

    // --- Start ---
    window.onload = function() {
        init();
    }
</script>

</body>
</html>

