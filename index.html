<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>System 6 - CELL.LIFE</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    
    <style>
        /* --- System 6 Theme Styles --- */
        :root {
            --sys-black: #000;
            --sys-white: #fff;
            --sys-grey: #aaa; 
            --shadow: 2px 2px 0px var(--sys-black);
        }

        body {
            font-family: 'VT323', monospace;
            background-color: #f0f0f0;
            /* Retro background pattern */
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), 
                              linear-gradient(-45deg, #ccc 25%, transparent 25%), 
                              linear-gradient(45deg, transparent 75%, #ccc 75%), 
                              linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 4px 4px;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            color: var(--sys-black);
            user-select: none;
            -webkit-user-select: none;
        }

        /* The Main Window */
        .window {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            box-shadow: 4px 4px 0px rgba(0,0,0,0.2);
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            margin-bottom: 20px;
        }

        /* Title Bar */
        .title-bar {
            background: var(--sys-black);
            color: var(--sys-white);
            padding: 4px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--sys-black);
            font-size: 1.2rem;
            letter-spacing: 1px;
        }
        
        .title-lines {
            flex-grow: 1;
            height: 12px;
            margin: 0 10px;
            background: repeating-linear-gradient(
                to bottom,
                var(--sys-white),
                var(--sys-white) 1px,
                var(--sys-black) 1px,
                var(--sys-black) 2px
            );
        }

        .close-box {
            width: 12px;
            height: 12px;
            background: var(--sys-white);
            border: 1px solid var(--sys-white);
            box-shadow: inset 1px 1px 0 #000;
            cursor: pointer;
        }

        /* Main Content Area */
        .content {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* Toolbar / Control Groups */
        .toolbar {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: space-around;
            padding-bottom: 5px;
            border-bottom: 1px dashed var(--sys-black);
        }

        .btn {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            padding: 5px 10px;
            font-family: 'VT323', monospace;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 2px 2px 0px var(--sys-black);
            transition: transform 0.1s;
            text-transform: uppercase;
            text-decoration: none;
            color: var(--sys-black);
            display: inline-block;
            text-align: center;
        }

        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: none;
            background: var(--sys-black);
            color: var(--sys-white);
        }

        .btn.active {
            background: var(--sys-black);
            color: var(--sys-white);
            box-shadow: inset 2px 2px 0px rgba(255,255,255,0.2);
        }

        .btn:disabled {
            color: #aaa;
            border-color: #aaa;
            box-shadow: none;
            cursor: default;
        }

        .control-group {
            display: flex;
            gap: 5px;
            align-items: center;
            border: 1px solid var(--sys-black);
            padding: 3px;
            flex-wrap: wrap; 
            justify-content: center;
        }

        .control-group-title {
            font-size: 0.8rem;
            font-weight: bold;
        }

        /* Canvas Area */
        .canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            background: #e0e0e0;
            padding: 10px;
            border: 1px inset var(--sys-black);
        }

        canvas {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            cursor: crosshair;
            image-rendering: pixelated;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            
            /* Responsive resizing */
            width: 100%;
            height: auto;
            max-width: 320px; /* Limit max size */
            aspect-ratio: 1 / 1; 
            touch-action: none; /* Prevents scrolling when interacting with the grid */
        }

        /* Simulation Controls */
        .simulation-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            flex-wrap: wrap;
        }

        .sim-control-buttons {
            display: flex;
            gap: 5px;
        }

        label {
            font-size: 1.1rem;
        }

        input[type="range"] {
            -webkit-appearance: none;
            background: transparent;
            width: 100px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            background: var(--sys-black);
            cursor: pointer;
            margin-top: -6px;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: var(--sys-black);
        }

        /* Info Panel */
        .info-panel {
            font-size: 1rem;
            text-align: center;
            padding: 5px 0 0;
            border-top: 1px dashed var(--sys-black);
        }
        
        /* Retro Modal Styles */
        .retro-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .retro-modal-window {
            background: var(--sys-white);
            border: 2px solid var(--sys-black);
            box-shadow: 6px 6px 0px rgba(0,0,0,0.5);
            width: 90%;
            max-width: 350px;
            display: flex;
            flex-direction: column;
        }

        .modal-content {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
            text-align: center;
        }

        .modal-text {
            font-size: 1.1rem;
            font-weight: bold;
            color: #d90429; /* A retro red for warnings */
            margin-bottom: 15px;
            padding: 5px;
            border: 1px dashed var(--sys-black);
            width: 100%;
            box-sizing: border-box;
        }


        /* Responsive */
        @media (max-width: 500px) {
            body { padding: 5px; }
            .btn { font-size: 0.9rem; padding: 4px 6px; }
            .control-group { flex-wrap: wrap; justify-content: center;}
            .simulation-controls { justify-content: center; gap: 10px;}
        }
    </style>
</head>
<body>

<div class="window">
    <div class="title-bar">
        <div class="close-box" onclick="closeModal()"></div>
        <div class="title-lines"></div>
        <span>CELL.LIFE</span>
        <div class="title-lines"></div>
    </div>

    <div class="content">
        <!-- Setup Controls -->
        <div class="toolbar">
            <div class="control-group">
                <span class="control-group-title">SETUP:</span>
                <!-- Removed redundant Toggle button -->
                <button class="btn" onclick="clearGrid()">Clear All</button>
                <button class="btn" onclick="randomizeGrid()">Random</button>
            </div>
            
            <div class="control-group">
                <span class="control-group-title">GRID:</span>
                <select id="grid-size" class="btn" onchange="changeGridSize()">
                    <option value="16">16x16</option>
                    <option value="32">32x32</option>
                    <option value="64">64x64</option>
                </select>
                <button class="btn" onclick="resetSimulation()" style="color:red; font-weight:bold;">RESET</button>
            </div>
        </div>

        <!-- Main Canvas -->
        <div class="canvas-container">
            <canvas id="editorCanvas" width="320" height="320"></canvas>
        </div>

        <!-- Simulation Controls -->
        <div class="simulation-controls">
            <div class="sim-control-buttons">
                <button class="btn" id="play-btn" onclick="toggleSimulation()">&#9658; START</button>
                <button class="btn" id="step-btn" onclick="stepSimulation()">STEP</button>
                <!-- Added Step Back Button -->
                <button class="btn" id="step-back-btn" onclick="stepBack()" disabled>&lt; BACK</button> 
            </div>
            <div style="display:flex; align-items:center; gap:5px;">
                <label>Speed:</label>
                <!-- Range is 1 (Slow) to 20 (Fast) -->
                <input type="range" id="speed-range" min="1" max="20" value="8" oninput="updateSpeed()">
            </div>
        </div>

        <!-- Info Panel / Future Achievement Display -->
        <div class="info-panel">
            Generation: <span id="generation-indicator">0</span> | Population: <span id="population-indicator">0</span>
        </div>
    </div>
</div>

<!-- Modal HTML structure for halting messages -->
<div id="retroModal" class="retro-modal-overlay" style="display: none;">
    <div class="retro-modal-window">
        <div class="title-bar">
            <div class="close-box" onclick="closeModal()"></div>
            <div class="title-lines"></div>
            <span>SIMULATION Halted</span>
            <div class="title-lines"></div>
        </div>
        <div class="modal-content">
            <p style="font-size: 1.2rem; margin-bottom: 10px;">SYSTEM MESSAGE:</p>
            <div id="modal-reason" class="modal-text"></div>
            <p>Generation: <span id="modal-generation">0</span></p>
            <p>Population: <span id="modal-population">0</span></p>
            <button class="btn" onclick="closeModal()">OKAY</button>
        </div>
    </div>
</div>


<script>
    // --- Configuration ---
    let gridSize = 16;
    const canvasSize = 320; 
    let pixelSize = canvasSize / gridSize;
    
    // --- State ---
    let grid = []; // 2D array: 0=dead, 1=alive
    let generation = 0;
    let population = 0;
    let gridHistory = []; // Stores previous grid states
    const maxHistory = 10; // Only store the last N generations for oscillation check and step back
    
    let isRunning = false;
    let runInterval = null;
    let fps = 8; // Frames (Generations) per second
    let isDrawing = false; // For mouse/touch interaction

    // --- DOM Elements ---
    const canvas = document.getElementById('editorCanvas');
    const ctx = canvas.getContext('2d');
    const playBtn = document.getElementById('play-btn');
    const stepBtn = document.getElementById('step-btn');
    const stepBackBtn = document.getElementById('step-back-btn');
    const genIndicator = document.getElementById('generation-indicator');
    const popIndicator = document.getElementById('population-indicator');
    const retroModal = document.getElementById('retroModal');
    const modalReason = document.getElementById('modal-reason');
    const modalGen = document.getElementById('modal-generation');
    const modalPop = document.getElementById('modal-population');
    
    // --- Initialization ---
    function init() {
        // Ensure grid settings match current dropdown (default 16x16)
        const select = document.getElementById('grid-size');
        gridSize = parseInt(select.value);
        pixelSize = canvasSize / gridSize;

        grid = createNewGrid(gridSize);
        gridHistory = []; // Ensure history is empty on init
        render();
        updateUI();
    }

    // --- Grid Logic ---

    /** * Creates and returns a new empty grid (all dead cells) of a specified size. 
     * This function is now pure and does NOT touch the global 'grid' variable.
     */
    function createNewGrid(size) {
        const newGrid = [];
        for (let y = 0; y < size; y++) {
            let row = [];
            for (let x = 0; x < size; x++) {
                row.push(0);
            }
            newGrid.push(row);
        }
        return newGrid;
    }

    /** Resets the simulation to a clean state. */
    function resetSimulation() {
        if (isRunning) stopSimulation();
        grid = createNewGrid(gridSize);
        generation = 0;
        population = 0;
        gridHistory = []; // Reset history
        render();
        updateUI();
    }

    /** Clears the grid (same as reset, but without stopping simulation if already stopped). */
    function clearGrid() {
        grid = createNewGrid(gridSize);
        generation = 0;
        population = 0;
        gridHistory = []; // Reset history
        render();
        updateUI();
    }

    /** Fills the grid with random living/dead cells. */
    function randomizeGrid() {
        if (isRunning) stopSimulation();
        const newGrid = [];
        for (let y = 0; y < gridSize; y++) {
            let row = [];
            for (let x = 0; x < gridSize; x++) {
                // 30% chance of being alive
                row.push(Math.random() < 0.3 ? 1 : 0);
            }
            newGrid.push(row);
        }
        grid = newGrid;
        generation = 0;
        gridHistory = []; // Clear history after randomization
        updatePopulation(); // Recalculate population after randomization
        render();
        updateUI();
    }

    /** Changes grid size and resets the simulation completely. */
    function changeGridSize() {
        const select = document.getElementById('grid-size');
        const newSize = parseInt(select.value);
        
        // Use a non-disruptive way to ask for confirmation
        if (population > 0 || generation > 0) {
            // NOTE: Using confirm temporarily as per previous examples, 
            // but will replace with a custom modal if requested.
            if(!confirm("Changing grid size will reset the current pattern and generation count. Continue?")) {
                select.value = gridSize; // Revert selection
                return;
            }
        }
        
        gridSize = newSize;
        pixelSize = canvasSize / gridSize;
        resetSimulation();
    }

    // --- Conway's Game of Life Core Logic ---
    
    /** Counts the number of live neighbors for a cell (x, y) on a specified grid. */
    function countNeighborsForGrid(x, y, targetGrid) {
        let count = 0;
        
        // Check all 8 surrounding cells
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue; // Skip the cell itself

                // Calculate neighbor coordinates (toroidal/wrapping edges)
                const nx = (x + dx + gridSize) % gridSize;
                const ny = (y + dy + gridSize) % gridSize;
                
                // Check if the neighbor is alive (1)
                count += targetGrid[ny][nx];
            }
        }
        return count;
    }

    /** Calculates the next state of the grid based on Conway's rules, returning the new grid and live count. */
    function calculateNextGeneration(inputGrid) {
        const nextGrid = createNewGrid(gridSize); 
        let liveCount = 0;

        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                const neighbors = countNeighborsForGrid(x, y, inputGrid);
                const state = inputGrid[y][x];

                // --- Conway's Rules (Combined logic) ---
                // State 1 (Alive): Survives if 2 or 3 neighbors. Dies otherwise.
                // State 0 (Dead): Becomes alive if 3 neighbors. Stays dead otherwise.
                const isAlive = state === 1;
                let newState = 0;

                if (isAlive && (neighbors === 2 || neighbors === 3)) {
                    newState = 1; // Survival
                } else if (!isAlive && neighbors === 3) {
                    newState = 1; // Reproduction
                }
                
                nextGrid[y][x] = newState;

                if (newState === 1) {
                    liveCount++;
                }
            }
        }
        return { nextGrid, liveCount };
    }
    
    /** Checks for halting conditions (stability, oscillation, extinction, overgrowth). */
    function checkStopConditions(currentGrid, nextGrid, liveCount) {
        const totalCells = gridSize * gridSize;
        let reason = null;

        // 3. Extinction/Overgrowth
        if (liveCount === 0) {
            reason = "EXTINCTION: All cells are dead. Life faded away.";
        } else if (liveCount === totalCells) {
            reason = "OVERGROWTH: Grid is completely filled. Maximum density reached.";
        }
        
        // Convert to string for easy comparison (Grid is an array of arrays)
        const currentGridString = JSON.stringify(currentGrid);
        const nextGridString = JSON.stringify(nextGrid);
        
        // 1. Stability (Current grid equals Next grid)
        if (!reason && currentGridString === nextGridString) {
            reason = "STABILITY: Pattern reached equilibrium (no visible movement).";
        }
        
        // 2. Oscillation (Next grid equals a recent previous grid in history)
        if (!reason) {
            for (let i = 0; i < gridHistory.length; i++) {
                if (nextGridString === JSON.stringify(gridHistory[i])) {
                    // gridHistory[i] is the state at Generation (current_gen - gridHistory.length + i)
                    const matchedGen = generation - gridHistory.length + i;
                    reason = `OSCILLATION: Pattern entered a loop (detected state matching Generation ${matchedGen}).`;
                    break;
                }
            }
        }
        
        return reason;
    }


    // --- Drawing Engine ---

    /** Draws the grid lines on the canvas. */
    function drawGridLines() {
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 0; i <= gridSize; i++) {
            ctx.moveTo(i * pixelSize, 0);
            ctx.lineTo(i * pixelSize, canvasSize);
            ctx.moveTo(0, i * pixelSize);
            ctx.lineTo(canvasSize, i * pixelSize);
        }
        ctx.stroke();
    }

    /** Draws a single cell. */
    function drawPixel(x, y, color) {
        ctx.fillStyle = color;
        const gap = 0; 
        ctx.fillRect(x * pixelSize + gap, y * pixelSize + gap, pixelSize - gap*2, pixelSize - gap*2);
    }

    /** Renders the entire grid state to the canvas. */
    function render() {
        ctx.clearRect(0, 0, canvasSize, canvasSize);
        drawGridLines();

        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                if (grid[y][x] === 1) {
                    drawPixel(x, y, '#000'); // Alive cell is Black
                }
                // Dead cells (0) are just the background color, no need to draw
            }
        }
    }

    // --- Interaction ---

    // The setTool function is removed as it's no longer necessary.

    /** Converts mouse/touch coordinates to grid coordinates. */
    function getGridCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        // Use rect.width/height for responsive calculation
        const x = Math.floor((clientX - rect.left) / (rect.width / gridSize));
        const y = Math.floor((clientY - rect.top) / (rect.height / gridSize));
        return { x, y };
    }

    /** Toggles the state of a cell on mouse/touch interaction. */
    function handleToggle(e) {
        if (isRunning) return; // Cannot edit while running
        
        const { x, y } = getGridCoords(e);
        if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
            // Toggles the state: 1 -> 0, or 0 -> 1
            const newState = 1 - grid[y][x]; 
            if (grid[y][x] !== newState) {
                // Save current state before toggle for the first step back
                if (generation === 0 && gridHistory.length === 0) {
                     gridHistory.push(grid.map(row => [...row])); // Save initial state
                }

                grid[y][x] = newState;
                render();
                // Recalculate population immediately after setup change
                updatePopulation();
                updateUI();
            }
        }
        // Critical for touch devices: prevent default scrolling/zooming
        if (e.cancelable) e.preventDefault();
    }

    // Interaction Listeners (Only on 'mousedown' or 'touchstart' for clean toggling)
    canvas.addEventListener('mousedown', (e) => { 
        if (!isRunning) handleToggle(e); 
        isDrawing = true; 
    });
    window.addEventListener('mouseup', () => { isDrawing = false; });
    
    canvas.addEventListener('touchstart', (e) => { 
        if (!isRunning) handleToggle(e); 
        isDrawing = true; 
    }, {passive: false});
    canvas.addEventListener('touchend', () => { isDrawing = false; });


    // --- Modal Functions ---

    function showModal(reason) {
        modalReason.innerText = reason;
        modalGen.innerText = generation;
        modalPop.innerText = population;
        retroModal.style.display = 'flex';
    }

    function closeModal() {
        retroModal.style.display = 'none';
    }


    // --- Simulation Controls ---

    /** Toggles the continuous simulation loop. */
    function toggleSimulation() {
        if (isRunning) stopSimulation();
        else startSimulation();
    }

    /** Starts the continuous simulation loop. */
    function startSimulation() {
        if (population === 0 && generation === 0) {
            // If starting from a clear board, prompt for a pattern
            if (gridSize > 0 && !confirm("The grid is empty! Start with a random pattern?")) {
                return;
            }
            randomizeGrid();
        }

        isRunning = true;
        playBtn.innerHTML = '&#9632; STOP';
        stepBtn.disabled = true;
        stepBackBtn.disabled = true;
        canvas.style.cursor = 'default';
        document.getElementById('grid-size').disabled = true;

        // Run the simulation loop
        runInterval = setInterval(() => {
            stepSimulation();
        }, 1000 / fps);
    }

    /** Stops the continuous simulation loop. */
    function stopSimulation() {
        isRunning = false;
        clearInterval(runInterval);
        playBtn.innerHTML = '&#9658; START';
        stepBtn.disabled = false;
        canvas.style.cursor = 'crosshair';
        document.getElementById('grid-size').disabled = false;
    }

    /** Executes one generation step. */
    function stepSimulation() {
        // 1. Store current state for history/stepBack
        const currentGridClone = grid.map(row => [...row]); // Deep clone for check and history
        
        // 2. Calculate next state
        const { nextGrid, liveCount } = calculateNextGeneration(currentGridClone);

        // 3. Check for stopping condition against the new state
        const haltReason = checkStopConditions(currentGridClone, nextGrid, liveCount);
        
        // 4. Store the current grid BEFORE moving to the next one
        gridHistory.push(currentGridClone);
        if (gridHistory.length > maxHistory) {
            gridHistory.shift();
        }

        // 5. Update global state to the next generation
        grid = nextGrid;
        population = liveCount;
        generation++;

        // 6. Render and update UI
        render();
        updateUI();

        // 7. Halt if a reason was found
        if (haltReason) {
            stopSimulation();
            showModal(haltReason);
        }
    }
    
    /** Executes one generation step backward. */
    function stepBack() {
        if (isRunning) stopSimulation();
        
        // Remove the current state that was just rendered (which is an incremented generation)
        // We need to revert to the last item in the history.
        if (gridHistory.length > 1) { 
            grid = gridHistory.pop(); // Revert to the previous state (the one before the current grid)
            generation--;
            updatePopulation(); // Recalculate based on restored grid
            render();
            updateUI();
        } else if (gridHistory.length === 1) {
             // If only the initial state is left, revert to it and reset generation/pop
             grid = gridHistory[0];
             gridHistory = []; // Clear history after reverting to original state
             generation = 0;
             updatePopulation();
             render();
             updateUI();
        }
    }


    /** Updates the FPS based on the slider, and restarts interval if running. */
    function updateSpeed() {
        const slider = document.getElementById('speed-range');
        fps = parseInt(slider.value);
        if (isRunning) {
            stopSimulation();
            startSimulation(); // Restart with new speed
        }
    }

    /** Recalculates the current population count. */
    function updatePopulation() {
        let count = 0;
        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                if (grid[y][x] === 1) count++;
            }
        }
        population = count;
    }

    // --- UI Update ---

    /** Updates the generation and population displays. */
    function updateUI() {
        genIndicator.innerText = generation;
        popIndicator.innerText = population;

        // Enable/Disable step button based on running state
        stepBtn.disabled = isRunning;
        
        // Enable/Disable step back button based on history size
        stepBackBtn.disabled = isRunning || gridHistory.length <= 1;
    }

    // --- Start ---
    window.onload = function() {
        init();
    }
</script>

</body>
</html>
